<?xml version="1.0"?>
<pdf>
  <page width="612" height="792" number="1">
    <region x="173.03" y="755.17" width="265.94" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">2014 NASA/ESA Conference on
Adaptive Hardware and S ystems (AHS)</region>
    <region x="83.55" y="687.99" width="444.89" height="42.68"
line_height="18.77" font="CDBJNF+NimbusRomNo9L-Regu">Considering
reconfiguration overhead in scheduling of dependent tasks on 2D
Reconfigurable FPGA</region>
    <region x="342.18" y="618.74" width="174.21" height="50.27"
line_height="10.32" font="CDBJNF+NimbusRomNo9L-Regu">Michael H&#xFC;bner
Ruhr-University Bochum, ESIT Bochum, Germany
Michael.Huebner@ruhr-uni-bochum.de</region>
    <region x="67.26" y="618.74" width="196.11" height="50.27"
line_height="10.32" font="CDBJNF+NimbusRomNo9L-Regu">Quang-Hai Khuat,
Daniel Chillet University of Rennes 1, IRISA/INRIA Lannion, France
{Quang-Hai.Khuat, Daniel.Chillet}@irisa.fr</region>
    <region x="434.09" y="568.5" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T3</region>
    <region x="519.92" y="568.42" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E3</region>
    <region x="496.63" y="568.42" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R3</region>
    <region x="356.12" y="561.64" width="21.13" height="18.68"
line_height="6.99" font="CDBLEA+Arial-ItalicMT">(( ( (2,5,M2)</region>
    <region x="391.26" y="556.62" width="3.22" height="5.68"
line_height="5.68" font="CDBLFB+Calibri-Italic">((</region>
    <region x="388.69" y="556.37" width="2.57" height="6.81"
line_height="6.81" font="CDBLFB+Calibri-Italic">(</region>
    <region x="434.09" y="556.04" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T2</region>
    <region x="501.54" y="555.96" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E2</region>
    <region x="478.8" y="555.96" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R2</region>
    <region x="541.31" y="554.05" width="5.87" height="6.5"
line_height="6.5" font="CDBKJE+ArialMT">b</region>
    <region x="395.59" y="549.83" width="20.64" height="6.99"
line_height="6.99" font="CDBLEA+Arial-ItalicMT">4 (((22,2,M )</region>
    <region x="444.54" y="544.5" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R1</region>
    <region x="459.06" y="544.48" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E1</region>
    <region x="559.74" y="544.05" width="2.2" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">t</region>
    <region x="434.09" y="543.94" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T1</region>
    <region x="323.05" y="543.52" width="20.64" height="17.85"
line_height="6.99" font="CDBLEA+Arial-ItalicMT">((( 1 (1,3,M )</region>
    <region x="508.8" y="535.67" width="11.75" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">9 10</region>
    <region x="441.92" y="535.67" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">0</region>
    <region x="523.19" y="535.67" width="13.65" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">11 12</region>
    <region x="478.88" y="535.67" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">5</region>
    <region x="448.77" y="535.67" width="18.04" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">1 2 3</region>
    <region x="486.37" y="535.56" width="11.0" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">6 7</region>
    <region x="470.65" y="535.56" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">4</region>
    <region x="537.64" y="535.52" width="20.46" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">13 14 15</region>
    <region x="501.54" y="535.52" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">8</region>
    <region x="401.95" y="531.78" width="5.87" height="6.5"
line_height="6.5" font="CDBKJE+ArialMT">a</region>
    <region x="351.74" y="529.33" width="20.63" height="18.13"
line_height="6.99" font="CDBLEA+Arial-ItalicMT">) (( ( 3 (3,3,M</region>
    <region x="434.01" y="490.31" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T3</region>
    <region x="539.03" y="490.23" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E3</region>
    <region x="519.43" y="490.23" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R3</region>
    <region x="328.37" y="488.54" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="434.01" y="477.85" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T2</region>
    <region x="486.26" y="477.77" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E2</region>
    <region x="456.79" y="477.77" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R2</region>
    <region x="351.52" y="468.36" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="543.81" y="468.18" width="5.48" height="6.5"
line_height="6.5" font="CDBKJE+ArialMT">c</region>
    <region x="444.46" y="466.31" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R1</region>
    <region x="458.98" y="466.29" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E1</region>
    <region x="434.01" y="465.75" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T1</region>
    <region x="559.66" y="465.32" width="2.45" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">t</region>
    <region x="523.11" y="457.47" width="13.65" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">11 12</region>
    <region x="478.81" y="457.47" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">5</region>
    <region x="448.7" y="457.47" width="18.04" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">1 2 3</region>
    <region x="508.73" y="457.47" width="11.75" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">9 10</region>
    <region x="441.85" y="457.47" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">0</region>
    <region x="486.29" y="457.36" width="11.0" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">6 7</region>
    <region x="470.58" y="457.36" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">4</region>
    <region x="501.47" y="457.33" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">8</region>
    <region x="537.56" y="457.33" width="20.46" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">13 14 15</region>
    <region x="502.18" y="431.18" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E2</region>
    <region x="479.63" y="431.18" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R2</region>
    <region x="434.4" y="430.74" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T2</region>
    <region x="328.74" y="430.58" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="368.86" y="419.85" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="434.38" y="418.73" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T3</region>
    <region x="459.74" y="418.2" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R3</region>
    <region x="481.36" y="418.15" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E3</region>
    <region x="332.75" y="410.4" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="543.81" y="409.24" width="5.87" height="6.5"
line_height="6.5" font="CDBKJE+ArialMT">d</region>
    <region x="444.83" y="406.74" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R1</region>
    <region x="459.35" y="406.72" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E1</region>
    <region x="560.03" y="406.28" width="2.2" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">t</region>
    <region x="434.38" y="406.18" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T1</region>
    <region x="523.48" y="397.9" width="13.65" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">11 12</region>
    <region x="479.17" y="397.9" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">5</region>
    <region x="449.06" y="397.9" width="18.04" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">1 2 3</region>
    <region x="509.09" y="397.9" width="11.75" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">9 10</region>
    <region x="442.21" y="397.9" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">0</region>
    <region x="486.66" y="397.79" width="11.0" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">6 7</region>
    <region x="470.94" y="397.79" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">4</region>
    <region x="537.93" y="397.76" width="20.46" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">13 14 15</region>
    <region x="501.83" y="397.76" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">8</region>
    <region x="48.96" y="384.76" width="251.07" height="209.95"
line_height="8.6" font="CDBJNH+NimbusRomNo9L-Medi">-Configuration
prefetching is known as an effective Abstract technique for hiding the
reconfiguration delay of hardware accelerators in Partial Region FPGA. In
prefetching, a hardware task can be loaded as soon as possible even if it
cannot execute immediately after its reconfiguration due to the involvement
of dependencies with other tasks. But due to the access in advance, the
configuration delay is hidden. This method can be compared with a software
prefetching in the processor domain. However, in the context of
reconfigurable architecture, the difficulties come from the dependencies of
prefetching with task scheduling and placement aspect. In this paper, we
introduce an run-time spatiotemporal scheduling heuristic for dependent
tasks executed on 2D heterogeneous FPGA. The objective is to reduce the
reconfiguration delay of tasks, thus minimize the total execution time of
an application. To achieve it, our proposed heuristic tries to prefetch
tasks as early as possible while considering two factors: the priority of
new tasks to be loaded and the placement decision to avoid conflicts among
tasks. The experiments show that our heuristic reduces significantly the
overall execution time by 22% compared to a non-prefetching method and
approximately 5% compared to other prefetching methods.</region>
    <region x="434.72" y="372.84" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T3</region>
    <region x="328.64" y="371.34" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="494.79" y="371.34" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E3</region>
    <region x="474.66" y="371.34" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R3</region>
    <region x="368.76" y="361.01" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="434.38" y="359.69" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T2</region>
    <region x="479.78" y="359.15" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E2</region>
    <region x="457.23" y="359.15" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R2</region>
    <region x="543.81" y="353.58" width="5.87" height="6.5"
line_height="6.5" font="CDBKJE+ArialMT">e</region>
    <region x="332.66" y="351.16" width="7.51" height="7.83"
line_height="7.83" font="CDBJPH+Calibri">(((</region>
    <region x="444.89" y="347.63" width="6.85" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">R1</region>
    <region x="459.41" y="347.61" width="6.61" height="4.07"
line_height="4.07" font="CDBKJE+ArialMT">E1</region>
    <region x="560.09" y="347.17" width="2.2" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">t</region>
    <region x="434.44" y="347.07" width="7.63" height="4.88"
line_height="4.88" font="CDBKJE+ArialMT">T1</region>
    <region x="523.55" y="338.8" width="13.65" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">11 12</region>
    <region x="479.24" y="338.8" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">5</region>
    <region x="449.13" y="338.8" width="18.04" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">1 2 3</region>
    <region x="509.16" y="338.8" width="11.75" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">9 10</region>
    <region x="442.28" y="338.8" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">0</region>
    <region x="486.72" y="338.68" width="11.0" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">6 7</region>
    <region x="471.01" y="338.68" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">4</region>
    <region x="501.9" y="338.65" width="3.3" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">8</region>
    <region x="537.99" y="338.65" width="20.46" height="3.66"
line_height="3.66" font="CDBKJE+ArialMT">13 14 15</region>
    <region x="311.97" y="300.05" width="251.06" height="25.44"
line_height="7.51" font="CDBJNF+NimbusRomNo9L-Regu">Fig. 1. -a-Example of
task graph, parameters under each task mean (reconfiguration time,
execution time and model of the task) -b, c, d, eDifferent scenarios of
task scheduling and placement for the task graph</region>
    <region x="311.97" y="81.64" width="251.07" height="203.31"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">possible whenever the
configuration controllers are available and positions are available for the
task on the FPGA. Even if the task cannot execute immediately after its
reconfiguration due the involvement of dependencies with other tasks, the
fact of hiding the reconfiguration phase by loading the task during the
execution of other tasks reduces significantly the reconfiguration
overhead. Despite the advantages offered by prefetching, this technique
could be inefficient if it does not combine with the scheduler at run time
to attribute correctly the time for loading tasks and the region to place
tasks. The ineffective order of tasks to be loaded could increase the
duration of overall execution time. Moreover, due to an ineffective
placement decision of a task, there is a possibility that other following
tasks ready to be scheduled could not find regions to be placed, therefore
they must wait until feasible regions are available. To prove the
importance of scheduling and placement in reconfiguration</region>
    <region x="47.57" y="60.8" width="252.46" height="311.08"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">NTRODUCTION I. I One of
the main research interests of FPGA is dynamic and partial reconfiguration
which allows a system to change fraction of its resources at runtime
without affecting the rest of the system. This feature obviously provides a
higher flexibility and more powerful computing per area to deal with the
dynamism of current multimedia applications requiring a high performance.
Nevertheless, Partial Reconfiguration (PR) does not come for free as it may
create a costly reconfiguration overhead, therefore an increase of the
overall latency of the application. For instance, loading (or
reconfiguring) one tenth of a Virtex XC2V6000 requires at least 4 ms or
loading a JPEG decoder task which occupies 30% of this Virtex, requires 12
ms with the reconfiguration circuitry running at maximum speed [1]. Another
example is : reconfiguring a device with a partial bitstream of 1.1 Mbytes
on a Virtex II-Pro could take 0.92 ms [2] if the Internal Configuration
Access Port (ICAP) is fed at the over-clock frequency of 300 Mhz. Thus,
developing techniques to minimize the reconfiguration time overhead, making
the use of PR more effective is crucial. Among several techniques,
configuration prefetching is known as an effective technique for hiding the
reconfiguration delay of hardware accelerators (tasks) in Partial Region
FPGA. The principle of prefetching is to load a task as soon as c
978-1-4799-5356-1/14/$31.00 2014 IEEE (</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">1</region>
  </page>
  <page width="612" height="792" number="2">
    <region x="311.97" y="352.98" width="251.07" height="380.14"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">take a significant
time. J. Resano et al [1] presented a hybrid prefetch heuristic scheduling
the reconfigurations at run time but carring out the scheduling
computations at design-time. K. Jiang et al [7] proposed a CLP formulation
and a heuristic that schedules prefetches and simultaneously performs HW/SW
partitioning in order to reduce the expected execution time of an
application. J. Edward [8] et. Al. presented an algorithm which predicts
hardware execution and tries to prefetch hardware as early as possible
while minimizing the risk of misprediction. The reconfigurable region is a
1D FPGA with n columns of the same size and they consider that the
placements of the hardware modules are fixed in advance. Y. Qu et al [9]
presented three static bases scheduler using prefetching, the first is
developed from list-based schedulers where each task has a priority
representing the urgency of the configuration. The second is based on
constraint programming and the last uses a guide random search strategy.
The target architecture is one-dimensional configuration model. J. Li [10]
presented an interesting configuration prefetching approach to reduce the
reconfiguration overhead for FPGA. However, the prediction for loading task
may be erroneous and the task is loaded with the consequent penalization.
The main difference of our work compared to all previous works is that in
our work, the loading time for each task is decided at runtime, we consider
that we do not have information about the entire future but only the very
near future. Moreover, while previous works target the 1D and/or 2D
homogenous FPGA, we address the 2D heterogeneous FPGA which is the case of
all most recent FPGAs. This heterogeneity imposes stricter placement
constraints for task and requires a different strategy of placement
compared to a homogenous FPGA.</region>
    <region x="48.95" y="328.95" width="251.07" height="404.16"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">overhead, an example
with different scheduling solutions for the task graph in Fig 1.a is
studied. Fig 1.b shows the case when prefetching technique is not used. Fig
1.c considers the prefetching but not the task placement. The placement of
T 2 prevents , performing cannot be loaded immediately after T T 3 3 .
After finishes its execution and is the reconfiguration of T T 2 1 can
still not start. Fig 1.d shows an removed from FPGA, T 3 example of
prefetching with consideration of placement for T 2 and but an ineffective
start of loading time. If is loaded T T 3 3 , the overall execution time
will be longer than in advance T 2 is loaded before. Therefore, the order
in Fig 1.e case when T 2 of tasks to be loaded and the placement decision
are extremely important parameters to reduce the reconfiguration overhead.
Finding the best solution in terms of overall execution time is an NP-hard
problem when task scheduling, placement and configuration prefetching all
need to be considered at one time. Different decisions of scheduling and
placement could produce different solutions of overall execution time. The
effort to find the best solution by seeking all the possibilities can not
be solvable in polynomial time. Thus, it is necessary to develop a run-time
spatio-temporal scheduling heuristic which is able to give a good solution
in a short time. To achieve it, in this paper, we propose a new heuristic
for run-time scheduling and placement of tasks on a 2D heterogeneous eFPGA
layer in order to minimize the overall latency of the application. Our
heuristic tries to load tasks as early as possible while considering two
factors: the priority of new tasks to be loaded and the placement decision
to avoid conflicts between tasks. The remainder of the paper is organized
as follows. The next section introduces the related work. Section 3
describes the architecture model, task model and the objective. Section 4
details our scheduling and placement heuristic. Section 5 presents the
experimental results and Section 6 concludes the paper with some
perspectives.</region>
    <region x="311.97" y="269.2" width="251.07" height="73.21"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">III. MODEL AND
OBJECTIVE In this section, we present the platform overview and explain how
the accelerators (tasks) are managed on it. Then we present the platform
model and the application model. From these models, the problem
formalization is presented at the end of this section.</region>
    <region x="48.96" y="66.1" width="251.07" height="252.49"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">TATE OF THE ART II. S
In the literature, several techniques have been addressed to reduce the
reconfiguration overhead, such as: configuration compression [3],
configuration caching [4] and configuration prefetching. Elena perez-ramo
et al [5] also proposed a survey of various techniques to reduce the
reconfiguration overhead. However, in this paper, we concentrate only on
the related works about configuration prefetching. F. Redaelli et al [6]
proposed an exact ILP formulation for the task scheduling problem on 2D
homogeneous reconfigurable FPGAs in order to minimize the overall latency
of the application. They proposed the Napoleon heuristic based on
prefetching technique that reaches a good solution in a short time but the
heuristic didn't allow finding a feasible schedule and mapping at runtime.
All decisions are taken at design-time, the heuristic must know in advance
the task graph in order to compute and sort the task set in increasing
order of ALAP values before starting the scheduling and placement step. It
is not always the case for applications where the behavior of tasks can be
changed at run time. Moreover, for complicated task graphs with many
dependent tasks, Napoleon heuristic could</region>
    <region x="311.97" y="66.1" width="251.07" height="192.72"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">A. Platform description
Our target 2D heterogeneous FPGA is inspired from the eFPGA layer of a 3D
stacked chip in the ongoing Flextiles project [11]. The 3D stacked chip is
composed of a manycore layer and a reconfigurable (eFPGA) layer as in Fig
2. The manycore layer contains several General Purpose Processor (GPP) and
Digital Signal Processor (DSP) cores. The reconfigurable layer, dedicated
for hardware accelerators, is used to provide a high level of flexibility
by support the feature of dynamic reconfigurable paradigm. The NoC on the
manycore layer is used to support the communication between processors,
between processors and accelerators, or between accelerators. In this
paper, we focus on the scheduling and placement of dependent accelerators
on a 2D heterogeneous reconfigurable architecture. Thus, we simplify the
Flextiles architecture in</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">2</region>
  </page>
  <page width="612" height="792" number="3">
    <region x="108.79" y="589.12" width="131.4" height="7.51"
line_height="7.51" font="CDBJNF+NimbusRomNo9L-Regu">Fig. 2. Flextiles
architecture Overview</region>
    <region x="48.96" y="341.48" width="251.07" height="236.3"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">order to reduce the
complexity of the problem. However, this reduction does not affect the mean
fullness of our approach but allows to focus on the essential research and
evaluation. This architecture is based on a large reconfigurable area
connected to one processor via a bus which supports the communication
between accelerators, see Fig 3. The processor supports the execution of an
Operating System able to control the task management. Furthermore, this
architecture contains a shared memory for the storage of data transferred
between tasks when needed. The 2D heterogeneous FPGA has different types of
resources, which are symmetrically located at fixed positions on the layer
(see Fig 3): computing resources (configurable logic blocks - CLBs), memory
resources (Blockram - BRAMs) for storing data during computations and
Accelerator Interfaces (AIs) to provide access points between processors
and accelerators. Fitting with the reconfigurable technology based on a
virtual bitstream, the symmetry of resources on the layer allows a high
flexibility in terms of accelerator relocation and increases the designer
degree of freedom.</region>
    <region x="216.98" y="318.76" width="42.4" height="10.81"
line_height="4.73" font="CDBKJE+ArialMT">Configurable Logic Block
(CLB)</region>
    <region x="216.98" y="299.12" width="31.02" height="10.81"
line_height="4.73" font="CDBKJE+ArialMT">Accelerator Interface
(AI)</region>
    <region x="83.49" y="284.87" width="14.84" height="11.3"
line_height="5.75" font="CDBMAE+Times-Italic">Fa &#x394;y</region>
    <region x="216.98" y="282.77" width="27.03" height="4.73"
line_height="4.73" font="CDBKJE+ArialMT">BRAM bloc</region>
    <region x="106.84" y="273.31" width="27.33" height="33.4"
line_height="8.24" font="CDBMAD+Symbol">Fb &#x394;y &#x394;x Fb Fa x
&#x394;</region>
    <region x="121.58" y="236.46" width="43.22" height="12.04"
line_height="5.32" font="CDBKJE+ArialMT">Communication bus</region>
    <region x="98.99" y="219.16" width="26.87" height="8.13"
line_height="8.13" font="CDBJPH+Calibri">((((( (((</region>
    <region x="158.46" y="215.32" width="23.72" height="15.81"
line_height="8.13" font="CDBJPH+Calibri">( ((((( (( ((((</region>
    <region x="119.63" y="193.6" width="109.72" height="7.51"
line_height="7.51" font="CDBJNF+NimbusRomNo9L-Regu">Fig. 3. 2D Heterogenous
FPGA</region>
    <region x="48.96" y="66.1" width="251.07" height="116.98"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">We consider that an
accelerator must contain at least one AI and one BRAM. The BRAM is used in
each accelerator to receive the data from other accelerators and also to
store data during its execution. The AI is used to homogenize the control
of accelerators by the processor, but also enables data transfer from/to
software and to/from hardware execution. The functionality of the AI is
supposed to be the same as in Flextiles and it offers various management
services as configuration, control, and debug. Each AI is connected to the
communication bus as described in Fig 3. When an accelerator</region>
    <region x="311.96" y="64.52" width="260.88" height="668.6"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">requires more than one
AI, one of them must become active and support the communications, others
stay inactive. If two accelerators need a data exchange, the operating
system must configure two I/O AIs of these two accelerators for setting up
the communication. Then, data will be sent from one AI to another AI. The
shared memory is needed when one accelerator must send data to another
accelerator which has not been configured yet due to some dependencies. B.
Platform model The execution platform for our problem is an FPGA which is
defined by its size , with and the width F w, F h F w F h ( ) and the
height of the FPGA in number of logic elements. Due to the symmetry of the
FPGA, the locations of BRAMs (or AIs) are defined by the distance between
two adjacent BRAMs (or AIs) but also by the position of the first instance
of the block. The horizontal (respectively vertical) distance between
(respectively ) and the position two BRAMs is F b F b x y &#x394; &#x394;
and . The of the first BRAM instance is given by F b F b x 0 y0 same
distances and initial position of first instance are defined for the AI, as
, , and . The coordinates F a F a F a F a x y x y &#x394; &#x394; 0 0
corresponds to the bottom left corner of the FPGA. , (0 0) From these
values, the size of FPGA and the location of the different elements can be
defined and all symmetrical FPGAs can be supported. An FPGA is then
completely defined by , F b , F b , F b , F P GA F w, F h , F b ) ( ) = ( )
( x y x y 0 0 &#x394; &#x394; { (1) F a , F a , F a , F a ( ) ( ) x y x y 0
0 &#x394; &#x394; } As an example, the FPGA represented in Fig 3 can be
defined as F P GA , , , , , , , , , = (30 18) (6 3) (8 8) (2 0) (8 8) { }
the total amount of BRAMs and We call Na Nb total total the total amount of
AIs on the FPGA; (respectively Nb total ) is computed by an evaluation of
the amount of Na total BRAMs (respectively AIs) which can be placed in the
area defined by . This computation is given by F w F h &#x2217; Nb F w F b
/F b = ( ( 1) + 1) total x x 0 &#x394; ( &#x2212; &#x2212; ( (2) F h F b /F
b ( ( 1) + 1) y y 0 &#x394; &#x2217; ( &#x2212; &#x2212; ( Reconfiguration
of hardware task on such platform consists in allocating a rectangular zone
and loading the bitstream towards the reconfiguration port. A task is
supposed relocatable in several regions of the FPGA, the possible regions
are defined by the presence of the necessary resources. In this context, as
FPGA definition, the model of an hardware task is defined by its size, and
the location of each specific block included inside. So this model is
defined as (3) Mw , Mh , Mb , Mb , Ma , Ma M = ( ) ( ) ( ) i i i i,x i,y
i,x i,y 0 0 0 0 { } and are the width and height of the model with Mh M Mw
i i i for a relocatable and reconfigurable task , T Mb , Mb ( ) i i,x i,y 0
0 , the position of the first instance of BRAM in the model M i the first
instance of AI in the model . and , Ma M Ma ) ( i,x i,y i 0 0 We define as
the amount of BRAMs required by task , Nb T i i T i for the task , Na T Nb
total i i the amount of AIs required by task . By applying the Na i and Nb
total and could be computed. Na same calculation as i</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">3</region>
  </page>
  <page width="612" height="792" number="4">
    <region x="48.95" y="68.1" width="251.07" height="665.2"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">C. DAG graph Similar to
some of previous works, we use Directed Acyclic Graph (DAG) to represent
dependent tasks. Applications, e.g. image processing, containing a linear
sequence of tasks which exchange large amounts of data between them, are
examples of this type of graph. DAG is denoted where is a G T, E T = ( )
set of nodes and is a set of directed edges. Each node N E N T e , while an
edge in DAG represents a task i , . . . , N T = 1 i T &#x2200; signifies
that data produced by one task is used by another one. A task is not ready
for scheduling until all its predecessors are finished, we note the list of
predecessors of tasks P red T ( ) i . which produce data for the task T i
As a task is a hardware task, it is necessary to specify not ) for each
task but also i) the only the execution time ( T run i ), and ii) the model
for ( ). reconfiguration time ( T M T rec i i i The communication time
between tasks is not considered since it is taken into account by the
execution time. Fig 1.a shows an example of DAG, each task is represented
by T i . The parameter of each task represents , T run , M M T rec ) ( i i
i i and is illustrated by the corresponding model of the task T i as in Fig
1.a. According to the the small rectangle next to T i = {(9,7), (6,0),
model definition of task, we can describe M 1 (2,5)}, = {(12,8), (6,1),
(2,6)}, etc. M 2 D. Formalization of the Spatio-temporal scheduling problem
The objective of our algorithm is to minimize the overall execution time of
dependent tasks running on 2D heterogeneous FPGA. To achieve that, the
scheduler must be able to handle all the following requests: when to
reconfigure a task (temporal reconfiguration) ? &#x2022; where to place the
task (spatial reconfiguration) ? &#x2022; when to start the execution of a
task according with its &#x2022; precedence constraints (temporal
scheduling) ? An ILP formalization for scheduling and placement of tasks on
2D homogenous FPGA is described in [6]. As we consider the heterogeneity of
the FPGA, different types of resources and also the placement constraints
of tasks on these resources must be taken into account. In this part, we
introduce a formalization with the objective function to optimize and the
main constraints of task scheduling and placement. We first &#x2022;
&#x2022; &#x2022; &#x2022; &#x2022; &#x2022; &#x2022; &#x2022; define some
variables as : time that starts to be loaded in FPGA T l T i i : time that
starts to be executed in FPGA T e T i i if is present on FPGA at time ,
otherwise; T a T t = 1 0 i,t i if can be placed on the reconfigurable P T =
1 T ,R i i k , otherwise. is defined below. zone R R 0 k k if the
reconfiguration port is free at time , F R t = 1 0 t otherwise. We suppose
that only one reconfiguration port is possible, i.e. only one task can be
loaded at a time. t T : amount of non-utilized BRAMs on FPGA at time Nb f,t
t : amount of non-utilized AIs on FPGA at time Na f,t : the overall
execution time of the task graph t global t max T e T run i , . . . , N = 1
with global i i { } &#x2200; the total amount of tasks in the graph = ( + )
; N</region>
    <region x="98.19" y="67.35" width="4.7" height="6.95"
line_height="6.95" font="CDBMEF+CMMI7">T</region>
    <region x="301.51" y="58.85" width="269.52" height="674.46"
line_height="9.7" font="CDBLKC+CMMI10">1) Objective: Minimizing the overall
execution time of the task graph defined as (5) min t ) ( global This
minimization must respect followings constraints: 2) Placement Constraints:
First of all, the minimization must ensure that all the tasks are scheduled
one and only one time during the execution of the application. This
constraint is defined as (6) P i , . . . N R = 1 = 1 k T ,R T i k |
&#x2200; &#x2203; a feasible region for the task , defined as with T R k i
(7) R Rx , Ry , Rx Mw , Ry Mh = + + k k k k i i i { } and the coordinates
of the reconfigurable zone with Ry Rx k k . We call a feasible region for
when and only when R T R k k i &#x2022; &#x2022; &#x2022; (4) it satisfies
three following conditions: The amount of BRAMs (respectively AIs) required
by must be less than the amount of non-utilized BRAMs T i (respectively
AIs) on the FPGA at time , for t t T l = i (8) Nb &lt; Nb Na &lt; Na &amp;
i f,t i f,t and are calculated by : Na Nb f,t f,t Nb Nb Nb T a = = 1 f,t
total j j,T l i ( &#x2212; | j (9) Na Na T a Na = = 1 f,t total j j,T l i (
&#x2212; | j If is placed at coordinate , all resources T Rx , Ry ( ) i k k
must fit on available resources of FPGA. This of T i condition can be
expressed by the following constraints Rx Mb F b m F b m N + = + k i,x x x
0 0 1 &#x394; 1 &#x2217; | &#x2203; &#x2208; (10) Ry Mb F b m F b m N + = +
k i,y y y 0 0 2 &#x394; 2 &#x2217; | &#x2203; &#x2208; Rx Ma F a m F a m N
+ = + k i,x x x 0 0 3 &#x394; 3 &#x2217; | &#x2203; &#x2208; (11) Ry Ma F a
m F a m N + = + k i,y y y 0 0 4 &#x394; 4 &#x2217; | &#x2203; &#x2208; The
first line of these constraints means that if the task T i is placed on the
reconfigurable zone , a first BRAM R k , or must be found at horizontal
relative position Mb i,x 0 absolute position . This verification is true if
Rx Mb + k i,x 0 a BRAM exists at this absolute position on the FPGA. We use
the symmetric formalization of the FPGA platform to verify if a BRAM is
located at a horizontal position . If exists, it means that a m F b m N F b
+ x x 0 1 &#x394; 1 &#x2217; &#x2208; BRAM is present at this location. The
same verifications are done for other BRAMs, and also AIs. The rectangle R
Rx , Ry , Rx Mw , Ry = ( + + k k k k i k does not overlap with other tasks
currently placed Mh ) i R P = 1 l T ,R j l ( &#x2203; | on the FPGA and
does not be larger than FPGA size. ) (12) T a j i = 1 = j,T l i &#x2227;
&#x2200; ( Rx &lt; Rx Mw ( + ) k l j &#x2227; Rx Mw &gt; Rx ( + ) k i l
&#x2227; k &#x2227; Ry ( k &#x2227; (0 &#x2227; &#x2264; (0 &#x2227;
&#x2264; Ry &lt; Ry Mh ( + ) l j Mh &gt; Ry + ) i l k Ry k Rx &lt; Rx Mw F
w + k i &#x2264; + ) k i &lt; Ry Mh F h &#x2264;</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">4</region>
  </page>
  <page width="612" height="792" number="5">
    <region x="311.97" y="601.53" width="251.07" height="131.76"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">: list of the tick time
for the operating system timeList t &#x2022; : list of tasks present on
FPGA at time currentT asks t &#x2022; : list of tasks available to be
scheduled at time T L t &#x2022; : list of next available successors of
whose predeL T i &#x2022; ) have all been scheduled and allocated cessors
(except T i : list containing tasks available to be scheduled at time P L
&#x2022; . is the fusion t and next available successors of P L T i list of
(without ) and T L T L i , , , , , : parameters deF P GA F R T rec T run T
e R i i i k &#x2022; fined in the previous section These parameters will be
updated at each time . t</region>
    <region x="508.28" y="516.03" width="11.87" height="6.57"
line_height="6.57" font="CDBJNF+NimbusRomNo9L-Regu">TL}</region>
    <region x="311.97" y="376.33" width="193.86" height="216.17"
line_height="7.51" font="CDBJNF+NimbusRomNo9L-Regu">Scheduling and
Placement heuristic function ScheduleAndPlacement { = 0 t = timeList
&#x2205; .add(StarterTask) T L while do T L = ( &#x2205; Update( , , ) F P
GA currentT asks F R for all do T i T L &#x2208; Establish : {Tj =
nextAvailableSuccessors(Ti) Tj L / | ) &#x2208; = P L T L T i L \ &#x222A;
findFewestConflictRegion( , ) R T i P L k &#x2190; if and ( == 0) then R F
R k &#x2203; = 1 F R .load( ) F P GA T i .add( ) currentT asks T i .add( +
, , + timeList i t T rec T e T e T run i i i .delete( ) T L T i .add( ) T L
L Sort in descending order of execution time T L break; end if end for )
.delete( ) timeList t = min( t timeList end while } Algorithm 1 1: 2: 3: 4:
5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24:
25:</region>
    <region x="48.96" y="66.1" width="251.07" height="667.02"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">The first five lines of
the constraint defined in equation 12 verifie that it does not exist
another rectangle R = l currently on the Rx , Ry , Rx Mw , Ry Mh ( + + ) l
l l j l j . The FPGA for which there is an intersection with R k must be
located last two lines of the constraint mean R k inside the FPGA area. can
be loaded at 3) Reconfiguration Constraints: A task T i on the FPGA when
and only when it satisfies time t T l = i the following conditions: At
least one feasible position for is found, i.e. R T k i &#x2022; (13) R P =
1 k T ,R i k &#x2203; | The configuration port at time is free; i.e T l i
&#x2022; (14) F R T l i = 0 All predecessors of finished their
reconfigurations, i.e T i &#x2022; (15) max T l T rec j T P red T T l ( + )
( ) i j j j i &#x2265; &#x2200; | &#x2208; can be executed at 4) Execution
Constraints: A task T i on the FPGA when and only when it satisfies time t
T e = i the following conditions: the reconfiguration of is finished, i.e.
T i &#x2022; (16) T e T l T rec + i i i &#x2265; all predecessors of
finished their executions, i.e. T i &#x2022; (17) T e max T e T run j T P
red T ( + ) ( ) i j j j i &#x2265; &#x2200; | &#x2208; CHEDULING AND
LACEMENT HEURISTIC P IV. S Even if the optimal solution could be found by
using Branch and Bound technique that searches for all ILP solutions first,
and then takes out the best solution, the effort in time required for the
calculation is large. Our heuristic targets runtime applications and does
not try to find the best solution but aims at finding a "good" solution in
terms of the overall execution time (equation 5) in a short time. As
mentioned earlier, in our case, the scheduler does not have information
about the entire task graph. Indeed, each task has uniquely the information
of its predecessors and its successors. We suppose that these informations
are only known by the operating system when the task is scheduled. The
algorithm is based on an heuristic which consists in prefetching tasks as
early as possible while considering two factors: the priority of new tasks
to be loaded and the placement decision to avoid conflicts between tasks.
The detail of our heuristic is given in two parts: Scheduling and
Placement. An example is given at the end of this section to ease the
understanding of our heuristic. A. Scheduling shows the pseudocode of our
heuristic. It is Algorithm 1 related to the spatio-temporal scheduling by
determining when and where to reconfigure a task and when a task can be
&#x2022; executed. We list here the parameters used in the pseudocode: :
current tick time of the operating system. is related to t t the time when
a task starts (or finishes) its reconfiguration or its execution</region>
    <region x="311.97" y="65.92" width="251.08" height="297.37"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">The works as follows.
At the beginning, Algorithm t 1 equals to 0, is empty and contains only the
timeList T L StarterTask (source) of the DAG task graph (line [2-4]). The
main part of the algorithm is presented from line [5-24] detailing what
happens at each time step . It is repeated until t is empty, i.e. all the
tasks have been scheduled. T L The function checks whether a task finishing
the Update reconfiguration or the execution at current time and then t
updates the state, the list and the F P GA currentT asks reconfigurator
port state. is busy during the reconfigF R F R uration phrase of a task and
becomes free when a task finished its reconfiguration. When a task finished
its execution, it will be removed from the and also from the F P GA
currentT asks list. After the updating phase, the scheduler will schedule
and allocate tasks of one by one. The order of tasks T L to be scheduled
follows their order in . At time T L t when is scheduled, the heuristic
tries to find the feaT i for placing onto FPGA in order to sible region T R
k i favor the placement of other remaining available tasks in . This region
and also next available successors of T L T i found by R f indF ewestConf
lictRegion T i, P L ( )funck tion, must satisfy the conditions for the
placement conwill be specified in f indF ewestConf lictRegion T i, P L (
straints mentioned in the formalization part. The details about )</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">5</region>
  </page>
  <page width="612" height="792" number="6">
    <region x="402.24" y="736.01" width="4.2" height="5.5"
line_height="5.5" font="CDBNOP+Arial-BoldMT">a</region>
    <region x="375.66" y="722.9" width="16.95" height="17.12"
line_height="4.66" font="CDBKJE+ArialMT">Begin = {} FP = 0 nb</region>
    <region x="473.11" y="712.15" width="6.14" height="6.41"
line_height="6.41" font="CDBJPH+Calibri">((</region>
    <region x="391.3" y="702.15" width="2.92" height="4.64"
line_height="4.18" font="CDBLFB+Calibri-Italic">(( (</region>
    <region x="370.75" y="701.82" width="20.55" height="10.53"
line_height="5.49" font="CDBOAA+Calibri">(( (( ( (((((( ( (((</region>
    <region x="403.24" y="687.95" width="4.48" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">F</region>
    <region x="370.43" y="682.84" width="26.73" height="9.08"
line_height="4.76" font="CDBLEA+Arial-ItalicMT">i ft ft &lt;= Na ) (Nb
&lt;= Nb ) i &amp; (Na</region>
    <region x="498.09" y="679.71" width="4.48" height="5.5"
line_height="5.5" font="CDBNOP+Arial-BoldMT">b</region>
    <region x="369.92" y="662.5" width="25.2" height="15.53"
line_height="4.58" font="CDBOAA+Calibri">T ((((((((((( ((((((( (((((
(</region>
    <region x="472.87" y="655.51" width="10.07" height="7.37"
line_height="6.41" font="CDBJPH+Calibri">(((((( ((</region>
    <region x="401.93" y="648.74" width="5.88" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">F</region>
    <region x="370.18" y="644.78" width="24.01" height="9.03"
line_height="3.99" font="CDBKJE+ArialMT">BRAM Non-utilized</region>
    <region x="48.95" y="627.46" width="251.07" height="105.82"
line_height="9.7" font="CDBLKC+CMMI10">the next section. If for exists
(condition 13) and the R T k i will be loaded reconfigurator is free
(condition 14), F R T i into the FPGA. Consequently, and timeList currentT
asks will be updated, available successors of will also be added T i to .
Then, to reduce the reconfiguration overhead, tasks in T L will be sorted
in descending order of their execution time. T L Finally, we jump to the
next tick time by performing the minimal value in is empty. (line [22-23])
and continue to schedule next task in timeList until T L T L</region>
    <region x="368.86" y="625.18" width="25.49" height="13.49"
line_height="5.49" font="CDBOAA+Calibri">T ( (( (((( ((((</region>
    <region x="498.09" y="624.06" width="4.2" height="5.5"
line_height="5.5" font="CDBNOP+Arial-BoldMT">c</region>
    <region x="403.39" y="608.78" width="4.48" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">F</region>
    <region x="370.27" y="605.35" width="24.24" height="3.99"
line_height="3.99" font="CDBKJE+ArialMT">BRAMs Fit</region>
    <region x="473.11" y="602.35" width="6.14" height="6.41"
line_height="6.41" font="CDBJPH+Calibri">((</region>
    <region x="495.13" y="601.52" width="6.14" height="6.41"
line_height="6.41" font="CDBJPH+Calibri">((</region>
    <region x="382.94" y="592.56" width="4.39" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">T</region>
    <region x="401.75" y="583.89" width="4.48" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">F</region>
    <region x="374.66" y="580.22" width="14.64" height="3.99"
line_height="3.99" font="CDBKJE+ArialMT">AIs Fit</region>
    <region x="498.09" y="570.57" width="4.48" height="5.5"
line_height="5.5" font="CDBNOP+Arial-BoldMT">d</region>
    <region x="383.18" y="567.39" width="4.39" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">T</region>
    <region x="402.56" y="557.9" width="4.48" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">F</region>
    <region x="369.48" y="552.1" width="32.58" height="8.34"
line_height="3.66" font="CDBKJE+ArialMT">NNon-overlap Rectangles</region>
    <region x="472.87" y="548.72" width="6.14" height="6.41"
line_height="6.41" font="CDBJPH+Calibri">((</region>
    <region x="519.01" y="547.89" width="6.14" height="6.41"
line_height="6.41" font="CDBJPH+Calibri">((</region>
    <region x="367.31" y="533.49" width="29.33" height="14.11"
line_height="5.57" font="CDBOAB+Calibri-Italic">T (( (((( (((((((((( ( ((((
&#x222A;</region>
    <region x="498.09" y="516.31" width="4.2" height="5.5"
line_height="5.5" font="CDBNOP+Arial-BoldMT">e</region>
    <region x="401.63" y="515.12" width="4.48" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">F</region>
    <region x="386.6" y="512.33" width="6.12" height="4.29"
line_height="4.29" font="CDBLEA+Arial-ItalicMT">total</region>
    <region x="370.27" y="511.98" width="16.33" height="5.72"
line_height="5.72" font="CDBLEA+Arial-ItalicMT">&#x2264; nb Nb</region>
    <region x="423.42" y="510.44" width="20.73" height="10.23"
line_height="3.99" font="CDBKJE+ArialMT">End Return FP</region>
    <region x="383.28" y="500.27" width="4.39" height="4.66"
line_height="4.66" font="CDBKJE+ArialMT">T</region>
    <region x="48.95" y="66.1" width="251.07" height="551.19"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">B. Placement This
section details the technique used in the function called by algorithm 1. ,
P L f indF ewestConf lictRegion T ) ( i The technique aims to find the most
suitable position for T i at time when it is scheduled, can be divided into
two parts: t the first part called Fast Feasible Region Search serves to
find at time on the quickly all feasible regions for the task t T i FPGA,
the second part called Avoiding Conflict Technique , then choose allows to
evaluate all the feasible regions for T i the most suitable one to place .
T i 1) Fast Feasible Region Search: To the best of our knowledge, most of
the hardware task placement algorithms deal with 1D or 2D FPGA homogenous
architecture, for example KAMER [12], Vertex List [13], etc. However, real
FPGAs have BRAM blocks, multipliers and DSPs in a certain disposition and
this heterogeneity imposes stricter placement constraints for the task. Few
algorithms deal with task placement on 2D heterogeneous architecture.
M.Koester [14] proposed a placement algorithm which is able to deal with
the constraints of the hardware tasks. However, feasible positions of the
task are not found in run-time. For each hardware task, the given set of
feasible positions is predefined at design time. Eiche et al. [15]
implemented an on-line placer for heterogeneous devices by using a discrete
hopfield neuronal network. They consider that the FPGA is divided in
several Partial Regions and a task must contain at least one of them. This
consideration can create a waste of resources when a task does not need the
entire resources in the PRR. In this part, we propose an efficient method
allowing to find on the 2D heterogeneous quickly all reconfigurable regions
R k can be matched at time . We define as the FPGA where t F P T i }).
Instead of seeking set of these feasible regions ( = { F P R k each logic
block along and of the FPGA to find a F w F h feasible region , which is
very time consuming, we propose R k to seek directly by the resources
having fewest amounts on FPGA. In our case, the amount of BRAMs is less
compared to AIs and CLBs, therefore we start scanning with BRAMs. The idea
is trying to place the task in the region where the first BRAM of matched
with a BRAM of the FPGA and T i checking whether the region created is a
feasible region for the . Thus, by placing the first BRAM of successively
task T T i i on all BRAMs of the FPGA, all feasible regions could be found.
By doing this way, the complexity for searching feasible regions is reduced
( * )/ times. F w F h Nb total Fig 4.a represents the proposed searching
method. Before scanning BRAMs, we realize a first check about the amount
of</region>
    <region x="311.96" y="65.19" width="251.07" height="414.71"
line_height="9.7" font="CDBLKC+CMMI10">Fig. 4. Quick search method for
finding all feasible regions for the task R k at time t T i non-utilized
BRAMs ( ) and AIs ( ) on the FPGA at Nb Na f,t f,t time (condition 8). If
the amount of BRAMs and AIs required t by the task is superior to the
amount of non-utilized BRAMs and AIs on the FPGA, no feasible region is
available for . T i On the contrary, we could start BRAMs scanning process.
The BRAMs scanning step consists in scanning each BRAM of the FPGA one by
one from the left to the right and then from the top to the bottom as in
the figure 4.c. For each scanning iteration , if the BRAM is utilized
(which is verified by nb BRAM non-utilized condition), we go to the next
iteration. If not, we calculate the region where the first BRAM of R T k i
can be matched with the BRAM of the FPGA. is a valid R k feasible region
for the task when the conditions 10, 11 and T i 12 are satisfied. BRAMs Fit
Condition is used to check if all other BRAMs of the tasks are matched on
the non-utilized BRAMs. If it is the case, the same process is done for AIs
Fit condition. When BRAMs Fit condition and AIs Fit condition are
satisfied, Non-overlap Rectangles (condition 12) must be respected to
ensure that the created region will not overlap R k with other regions
where other tasks are running and/or with is a valid feasible region, it
the border of the FPGA. Once R k is added to and we scan the next BRAM
until all BRAMs F P of the FPGA are scanned. Fig 4.b presents an example
with is currently on the T 1 . Fig FPGA and we must find all feasible
regions for T 2 with BRAM Non-utilized 4.c shows an invalid region for T 2
condition not satisfied, Fig 4.d shows an invalid region with BRAMs Fit and
AIs Fit condition satisfied but Non-overlap At time , t are found, T i
chooses the most rectangles condition not satisfied. Fig 4.e shows a valid
feasi. ble region for T 2 2) Avoiding conflicts technique: once all , P L f
indF ewestConf lictRegion T ) ( feasible regions for i</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">6</region>
  </page>
  <page width="612" height="792" number="7">
    <region x="349.46" y="729.85" width="10.93" height="11.39"
line_height="11.39" font="CDBJPH+Calibri">(((</region>
    <region x="508.77" y="721.49" width="10.93" height="11.39"
line_height="11.39" font="CDBJPH+Calibri">(((</region>
    <region x="479.61" y="714.39" width="13.91" height="26.75"
line_height="11.39" font="CDBJPH+Calibri">((( (((</region>
    <region x="414.69" y="714.07" width="13.88" height="27.17"
line_height="11.39" font="CDBJPH+Calibri">((( (((</region>
    <region x="500.18" y="699.17" width="12.97" height="5.32"
line_height="5.32" font="CDBKJE+ArialMT">t = 3</region>
    <region x="432.45" y="699.17" width="12.97" height="5.32"
line_height="5.32" font="CDBKJE+ArialMT">t = 1</region>
    <region x="369.76" y="699.17" width="12.97" height="5.32"
line_height="5.32" font="CDBKJE+ArialMT">t = 0</region>
    <region x="443.82" y="665.07" width="10.93" height="11.39"
line_height="11.39" font="CDBJPH+Calibri">(((</region>
    <region x="378.97" y="664.97" width="10.93" height="11.39"
line_height="11.39" font="CDBJPH+Calibri">(((</region>
    <region x="417.64" y="657.97" width="10.93" height="11.39"
line_height="11.39" font="CDBJPH+Calibri">(((</region>
    <region x="517.81" y="657.93" width="6.57" height="21.95"
line_height="11.39" font="CDBJPH+Calibri">( ((</region>
    <region x="352.79" y="657.88" width="10.93" height="11.39"
line_height="11.39" font="CDBJPH+Calibri">(((</region>
    <region x="500.82" y="642.86" width="12.97" height="5.32"
line_height="5.32" font="CDBKJE+ArialMT">t = 9</region>
    <region x="432.33" y="642.86" width="12.97" height="5.32"
line_height="5.32" font="CDBKJE+ArialMT">t = 6</region>
    <region x="369.16" y="642.86" width="12.97" height="5.32"
line_height="5.32" font="CDBKJE+ArialMT">t = 4</region>
    <region x="48.95" y="496.68" width="251.08" height="236.61"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">suitable one that
creates fewest conflicts with tasks in , P L therefore favors the placement
of next available tasks, to place . As mentioned, contains the next
available tasks T P L i . We define parameters and and the next successors
of p q T i with tasks in . which allow to evaluate the conflicts of P L T i
, noted is found Firstly, the set of feasible regions for F P T i by using
Fast Feasible Region Search presented in the previous part. Then, for each
, we calculate the amount of R F P k &#x2208; is supposed to be feasible
regions for each task in if P L T i . is defined as the multiplication of
all these placed at p R k amounts, and as the sum of all these amounts.
Thus, for all q , the maximum value of , called feasible regions of p pmax
T i and the maximum value of , call could be determined. q qmax equals 0
means one of the task in can not be placed due p P L to the feasible
position if is placed on. This task must wait T i or other tasks to have
the chance to until the extraction of T i be placed, thus delaying the
execution of the following tasks. The more larger is, the more the tasks in
have the chance p P L to be placed simultaneously on the FPGA, thus the
more the reconfiguration overhead is reduced.</region>
    <region x="199.81" y="479.92" width="9.81" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">R4</region>
    <region x="227.39" y="479.91" width="9.81" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">R5</region>
    <region x="109.79" y="479.43" width="9.81" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">R1</region>
    <region x="255.12" y="479.36" width="11.56" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">R.6</region>
    <region x="139.0" y="479.36" width="9.81" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">R2</region>
    <region x="169.42" y="479.22" width="9.81" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">R3</region>
    <region x="87.55" y="454.69" width="5.26" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">p</region>
    <region x="162.32" y="454.65" width="16.46" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4*1</region>
    <region x="133.44" y="454.58" width="16.46" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">3*1</region>
    <region x="249.49" y="454.58" width="16.46" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4*1</region>
    <region x="221.55" y="454.58" width="16.46" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">3*1</region>
    <region x="192.71" y="454.58" width="16.46" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4*2</region>
    <region x="106.63" y="454.23" width="11.21" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4*2</region>
    <region x="87.55" y="432.52" width="5.26" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">q</region>
    <region x="162.32" y="432.49" width="17.69" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4+1</region>
    <region x="133.44" y="432.42" width="17.69" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">3+1</region>
    <region x="249.49" y="432.42" width="17.69" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4+1</region>
    <region x="221.55" y="432.42" width="17.69" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">3+1</region>
    <region x="192.71" y="432.42" width="17.69" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4+2</region>
    <region x="106.63" y="432.06" width="12.44" height="5.82"
line_height="5.82" font="CDBKJE+ArialMT">4+2</region>
    <region x="311.97" y="251.72" width="251.07" height="377.6"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">Fig. 6. Scheduling and
placement of tasks on 2D heterogenous FPGA starts its execution. At that
time, the reconfigurator becomes can start the reconfiguration. The
placement of free and T T 2 2 must favor the placement of next available
task which is , T 3 is placed as in the figure. At time 3, finished
therefore T T 2 2 its reconfiguration but it cannot start the execution
phase due . The reconfigurator is free at to the unfinished execution of T
1 can start its reconfiguration. The placement of time 3, thus T 3 must
favor the next available task . However, no available T T 3 4 feasible
region for is found wherever is placed on the T T 4 3 finished its
execution and is removed FPGA. At time 4, T 1 starts its execution. At time
6, finished from the FPGA, T T 2 3 its reconfiguration and starts its
execution. Finally, at time 9, and are finished their executions and are
removed from T T 2 3 the FPGA. can now be loaded. is placed far from the T
T 4 4 center as in the figure to favor the placement of next available is
the last task to be scheduled, tasks. In the example, T 4 . After the time
9, thus there are no available tasks after T T 4 4 will continue the
reconfiguration and execution. At time 13, finished its execution and is
removed from the FPGA. We T 4 mark 13 as the overall execution time for the
task graph. ESULTS V. R In order to evaluate the quality of our proposed
heuristic, we generate different examples of DAG graphs and compare the
results produced by our heuristic to other techniques. The amount of tasks
ranges from 5 to 14 tasks for each graph. N T In each graph, except the
source task, one task has at least one predecessor. The reconfiguration
time and the execution time range from 1 to 10 time units for each task,
the width and the height of each task vary in the interval [6, 18]. A task
must contain at least one AI and one BRAM.</region>
    <region x="375.57" y="151.02" width="147.63" height="90.37"
line_height="6.69" font="CDBJNH+NimbusRomNo9L-Medi">41 39.06 39 48.06 39 39
60.43 54 54 56.5 41.63 41 62.88 48 48 68.41 52.18 51 79.84 68 68 69.88 56
56 74.98 58.48 58 102.7 87 87 FFWOP RFWP Napoleon_ex Proposed 33 33 53 40
44 51 66 57 58 84</region>
    <region x="351.8" y="151.02" width="10.45" height="90.53"
line_height="6.57" font="CDBJNF+NimbusRomNo9L-Regu">N T 5 6 7 8 9 10 11 12
13 14</region>
    <region x="422.31" y="136.62" width="30.38" height="7.51"
line_height="7.51" font="CDBJNF+NimbusRomNo9L-Regu">TABLE I</region>
    <region x="323.27" y="125.22" width="233.49" height="5.26"
line_height="5.26" font="CDBJNF+NimbusRomNo9L-Regu">OMPARISONS OF THE
OVERALL EXECUTION TIME FOR DIFFERENT TECHNIQUES</region>
    <region x="318.27" y="124.9" width="4.65" height="6.57"
line_height="6.57" font="CDBJNF+NimbusRomNo9L-Regu">C</region>
    <region x="311.97" y="66.1" width="251.06" height="45.25"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">To offer more
flexibility for task placement, we simulate the bigger FPGA described as
FPGA = {(36,34), (6,3), (8,8), (2,0), (8,8)}. We compare our proposed
heuristic with three different techniques: i) First Fit Without Prefetching
(FFWOP), ii)</region>
    <region x="48.95" y="65.17" width="251.07" height="349.16"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">Fig. 5. Calculation of
parameters and to decide the placement of in p q T 1 and order to avoid
conflicts with T 2 3 T Our placement decision of is based on the region
giving T i the value of in the case is different to 0. If there pmax pmax
giving this value of , is only one feasible region for pmax T i will be
placed at this feasible region. In the case many T i feasible regions are
possible, we will take the first furthest feasible region from the center.
If is equal to 0, we will pmax take the region giving to finally place .
The more qmax T i larger is, the more choices to place tasks in we have. q
P L give the same , In the case many feasible regions for qmax T i we will
take the first furthest feasible region from the center. Fig 5 shows an
example how to choose the suitable region of the task graph in Fig 1.a. By
using the quick to place T 1 denoted , , search method, six feasible
regions for R R T 1 1 2 etc. are found. According to the task graph and the
scheduling algorithm, contains next available successors of which P L T 1
and . For each feasible region of , and are are T T p q T 2 3 1 , 4
feasible regions for and calculated. For example, for T R 1 2 are found,
etc. Finally, seeing that 2 feasible regions for T 3 will be chosen to
place . is equal to , T pmax R 8 1 1 C. Example Fig 6 shows by time steps
the scheduling and placement of tasks defined in DAG of Fig 1.a. Three
different colors are used to differentiate the reconfiguration phase, the
execution phase of are and , thus is placed as in Fig 6 at time 0 T T T 1 2
3 and . spends 1 time unit to favor the placement of T T 3 1 finished its
reconfiguration and to reconfigure. At time 1, or pending the execution of
a task. Next available successors T 1 T T 2 1</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">7</region>
  </page>
  <page width="612" height="792" number="8">
    <region x="311.97" y="94.9" width="251.07" height="638.22"
line_height="7.66" font="CDBLLE+NimbusRomNo9L-ReguItal">heterogeneous FPGA.
We present as well a technique allowing to search quickly feasible
positions of the task on the FPGA. The results show that our proposed
heuristic reduces significantly the overall execution time compared to some
nonprefetching and other prefetching methods. This work will be extended by
taking into account : i) the reused module for a hardware task and ii) the
software executions, thus a task can exist in hardware and/or software. An
efficient scheduler must be proposed in order to give a good solution in
term of the overall time of the application. REFERENCES [1] J. Resano, D.
Mozos, and F. Catthoor, "A hybrid prefetch scheduling heuristic to minimize
at run-time the reconfiguration overhead of dynamically reconfigurable
hardware," in Proceedings of the conference on Design, Automation and Test
in Europe-Volume 1. IEEE Computer Society, 2005, pp. 106-111. [2] C. Claus,
F. Altenried, and W. Stechele, "Dynamic partial reconfiguration of xilinx
fpgas lets system adapt on the fly," Xcell journal, pp. 18-23, 2010. [3] Z.
Li and S. Hauck, "Configuration compression for virtex fpgas," in
Field-Programmable Custom Computing Machines, 2001. FCCM'01. The 9th Annual
IEEE Symposium on. IEEE, 2001, pp. 147-159. [4] Z. Li, K. Compton, and S.
Hauck, "Configuration caching management techniques for reconfigurable
computing," in Field-Programmable Custom Computing Machines, 2000 IEEE
Symposium on. IEEE, 2000, pp. 22-36. [5] E. P. Ramo, J. Resano, D. Mozos,
and F. Catthoor, "Reducing the reconfiguration overhead: a survey of
techniques." in ERSA, 2007, pp. 191-194. [6] F. Redaelli, M. D.
Santambrogio, and S. O. Memik, "An ilp formulation for the task graph
scheduling problem tailored to bi-dimensional reconfigurable
architectures," International Journal of Reconfigurable Computing, vol.
2009, p. 7, 2009. [7] K. Jiang, P. Eles, and Z. Peng, "Co-design techniques
for distributed real-time embedded systems with communication security
constraints," in Design, Automation &amp;amp; Test in Europe Conference
&amp;amp; Exhibition (DATE), 2012. IEEE, 2012, pp. 947-952. [8] J. E. Sim,
W.-F. Wong, G. Walla, T. Ziermann, and J. Teich, "Interprocedural
placement-aware configuration prefetching for fpga-based systems," in
Field-Programmable Custom Computing Machines (FCCM), 2010 18th IEEE Annual
International Symposium on. IEEE, 2010, pp. 179-182. [9] Y. Qu, J.-P.
Soininen, and J. Nurmi, "A parallel configuration model for reducing the
run-time reconfiguration overhead," in Proceedings of the conference on
Design, automation and test in Europe: Proceedings. European Design and
Automation Association, 2006, pp. 965-969. [10] Z. Li, "Configuration
management techniques for reconfigurable computing," Ph.D. dissertation,
Citeseer, 2002. [11] F. Lemonnier, P. Millet, G. M. Almeida, M. Hubner, J.
Becker, S. Pillement, O. Sentieys, M. Koedam, S. Sinha, K. Goossens et al.,
"Towards future adaptive multiprocessor systems-on-chip: an innovative
approach for flexible architectures," in Embedded Computer Systems (SAMOS),
2012 International Conference on. IEEE, 2012, pp. 228-235. [12] K.
Bazargan, R. Kastner, and M. Sarrafzadeh, "Fast template placement for
reconfigurable computing systems," IEEE Design &amp;amp; Test of Computers,
vol. 17, no. 1, pp. 68-83, 2000. [13] J. Tabero, J. Septi&#xE9;n, H. Mecha,
and D. Mozos, "Allocation heuristics and defragmentation measures for
reconfigurable systems management," Integration, the VLSI Journal, vol. 41,
no. 2, pp. 281-296, 2008. [14] M. Koester, M. Porrmann, and H. Kalte, "Task
placement for heterogeneous reconfigurable architectures," in
Field-Programmable Technology, 2005. Proceedings. 2005 IEEE International
Conference on. IEEE, 2005, pp. 43-50. [15] A. Eiche, D. Chillet, S.
Pillement, and O. Sentieys, "Task placement for dynamic and partial
reconfigurable architecture," in Design and Architectures for Signal and
Image Processing (DASIP), 2010 Conference on. IEEE, 2010, pp.
228-234.</region>
    <region x="48.95" y="66.1" width="251.08" height="667.02"
line_height="9.38" font="CDBJNF+NimbusRomNo9L-Regu">Random Fit With
Prefetching (RFWP) and iii) Napoleon (Napoleon_ex). The FFWOP algorithm
does not consider the prefetching technique and the order of tasks to be
loaded into the FPGA. In FFWP, tasks are placed at the first available
region. RRWP considers the prefetching technique but not the order of
tasks. In RRWP, tasks are placed randomly on the FPGA at one of its
feasible positions. Napoleon's heuristic [6] is very close to our heuristic
by considering the prefetching technique and also the task placement.
Compared to the Napoleon, our heuristic has two different points: i) While
Napoleon algorithm computes the order of tasks to be scheduled at
design-time, our algorithm attributes the priority for the tasks at
run-time. ii) The placement in Napoleon algorithm addresses the 2D
homogenous FPGA and it uses furthest placement criteria in order to
increase the probability of placing large modules quickly. In our
heuristic, the placement takes care of 2D heterogeneous FPGA and the new
task will be placed in the region creating fewest conflicts with other
tasks. To compare our heuristic with Napoleon, we extend the basic Napoleon
to take into account of the heterogeneity of the task and the FPGA. The
table I shows the comparisons of the overall execution time produced by our
proposed heuristic with FFWOP, RFWP and Napoleon extension. In this table,
10 examples of task graph are analyzed. Because FFWOP, RFWP and Napoleon do
not consider the order of tasks to be loaded into the FPGA, thus at time
when several tasks are ready to be scheduled, a t task is chosen randomly
among these tasks to be scheduled. In our examples, for each task graph,
FFWOP, RFWP and Napoleon are run 100 times each with the order of tasks is
randomly chosen every time. The values produced by FFWOP, RFWP and Napoleon
in the table I are the average overall time of these 100 times. By
performing the random order of tasks, we can compare fairly our heuristic
with others. For almost cases, our heuristic gives the shortest overall
execution time. According to the table I, our heuristic considering the
order of tasks to be loaded and the avoid conflict placement technique
reduces significantly by 22,5% the overall execution time compared to FFWOP
and approximately 5% equals compared to RFWP and Napoleon. In the case with
N T 12, the overall execution time produced by our proposed heuristic are
slightly greater than RFWP and Napoleon. This difference is due to the fact
that the scheduler does not have the entire information of the task graph.
The information about the successors of a task is only known when the task
starts reconfiguring into the FPGA, therefore at the time the list of t
next available tasks contains only tasks which will be ready to be
scheduled in the near future from . Then, our heuristic t favors the
placement of next available tasks but cannot predict the placement of far
future tasks. However, in some case, the placement of the task at the time
can impact on the T t i that was not in the next available task list
placement of T j at time . t ONCLUSION VI. C In this work, we introduce a
heuristic to minimize the overall execution time of dependent tasks
executed on 2D</region>
    <region x="303.75" y="25.28" width="4.5" height="9.01"
line_height="9.01" font="CDBLIC+TimesNewRoman">8</region>
  </page>
</pdf>
