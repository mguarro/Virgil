
  
    
      2014 NASA/ESA Conference on Adaptive Hardware and S
      ystems (AHS)
    
    
      Considering reconfiguration overhead in scheduling of
      dependent tasks on 2D Reconfigurable FPGA
    
    
      Michael Hübner
      Ruhr-University Bochum, ESIT
      Bochum, Germany
      Michael.Huebner@ruhr-uni-bochum.de
    
    
      Quang-Hai Khuat, Daniel Chillet
      University of Rennes 1, IRISA/INRIA
      Lannion, France
      {Quang-Hai.Khuat, Daniel.Chillet}@irisa.fr
    
    
      T3 
    
    
      E3 
    
    
      R3 
    
    
      
      
      (2,5,M2) 
    
    
      
    
    
      
    
    
      T2 
    
    
      E2 
    
    
      R2 
    
    
      b 
    
    
      4
      (((22,2,M ) 
    
    
      R1 
    
    
      E1 
    
    
      t 
    
    
      T1 
    
    
      
      1
      (1,3,M ) 
    
    
      9 10 
    
    
      0 
    
    
      11 12 
    
    
      5 
    
    
      1 2 3 
    
    
      6 7 
    
    
      4 
    
    
      13 14 15 
    
    
      8 
    
    
      a 
    
    
      ) 
      
      
      3
      (3,3,M
    
    
      T3 
    
    
      E3 
    
    
      R3 
    
    
      
    
    
      T2 
    
    
      E2 
    
    
      R2 
    
    
      
    
    
      c 
    
    
      R1 
    
    
      E1 
    
    
      T1 
    
    
      t 
    
    
      11 12 
    
    
      5 
    
    
      1 2 3 
    
    
      9 10 
    
    
      0 
    
    
      6 7 
    
    
      4 
    
    
      8 
    
    
      13 14 15 
    
    
      E2 
    
    
      R2 
    
    
      T2 
    
    
      
    
    
      
    
    
      T3 
    
    
      R3 
    
    
      E3 
    
    
      
    
    
      d 
    
    
      R1 
    
    
      E1 
    
    
      t 
    
    
      T1 
    
    
      11 12 
    
    
      5 
    
    
      1 2 3 
    
    
      9 10 
    
    
      0 
    
    
      6 7 
    
    
      4 
    
    
      13 14 15 
    
    
      8 
    
    
      -Configuration prefetching is known as an effective
      Abstract
      technique for hiding the reconfiguration delay of hardware
      accelerators in Partial Region FPGA. In prefetching, a hardware
      task can be loaded as soon as possible even if it cannot execute
      immediately after its reconfiguration due to the involvement of
      dependencies with other tasks. But due to the access in advance,
      the configuration delay is hidden. This method can be compared
      with a software prefetching in the processor domain. However, in
      the context of reconfigurable architecture, the difficulties come
      from the dependencies of prefetching with task scheduling and
      placement aspect. In this paper, we introduce an run-time spatio-
      temporal scheduling heuristic for dependent tasks executed on
      2D heterogeneous FPGA. The objective is to reduce the recon-
      figuration delay of tasks, thus minimize the total execution time
      of an application. To achieve it, our proposed heuristic tries to
      prefetch tasks as early as possible while considering two factors:
      the priority of new tasks to be loaded and the placement decision
      to avoid conflicts among tasks. The experiments show that our
      heuristic reduces significantly the overall execution time by 22%
      compared to a non-prefetching method and approximately 5%
      compared to other prefetching methods.
    
    
      T3 
    
    
      
    
    
      E3 
    
    
      R3 
    
    
      
    
    
      T2 
    
    
      E2 
    
    
      R2 
    
    
      e 
    
    
      
    
    
      R1 
    
    
      E1 
    
    
      t 
    
    
      T1 
    
    
      11 12 
    
    
      5 
    
    
      1 2 3 
    
    
      9 10 
    
    
      0 
    
    
      6 7 
    
    
      4 
    
    
      8 
    
    
      13 14 15 
    
    
      Fig. 1. -a-Example of task graph, parameters under each task mean
      (reconfiguration time, execution time and model of the task) -b, c, d, e-
      Different scenarios of task scheduling and placement for the task graph
    
    
      possible whenever the configuration controllers are available
      and positions are available for the task on the FPGA. Even if
      the task cannot execute immediately after its reconfiguration
      due the involvement of dependencies with other tasks, the
      fact of hiding the reconfiguration phase by loading the task
      during the execution of other tasks reduces significantly the
      reconfiguration overhead.
      Despite the advantages offered by prefetching, this tech-
      nique could be inefficient if it does not combine with the
      scheduler at run time to attribute correctly the time for loading
      tasks and the region to place tasks. The ineffective order of
      tasks to be loaded could increase the duration of overall execu-
      tion time. Moreover, due to an ineffective placement decision
      of a task, there is a possibility that other following tasks ready
      to be scheduled could not find regions to be placed, therefore
      they must wait until feasible regions are available. To prove
      the importance of scheduling and placement in reconfiguration
    
    
      NTRODUCTION
      I. I
      One of the main research interests of FPGA is dynamic
      and partial reconfiguration which allows a system to change
      fraction of its resources at runtime without affecting the rest of
      the system. This feature obviously provides a higher flexibility
      and more powerful computing per area to deal with the
      dynamism of current multimedia applications requiring a high
      performance. Nevertheless, Partial Reconfiguration (PR) does
      not come for free as it may create a costly reconfiguration
      overhead, therefore an increase of the overall latency of the
      application. For instance, loading (or reconfiguring) one tenth
      of a Virtex XC2V6000 requires at least 4 ms or loading a
      JPEG decoder task which occupies 30% of this Virtex, requires
      12 ms with the reconfiguration circuitry running at maximum
      speed [1]. Another example is : reconfiguring a device with
      a partial bitstream of 1.1 Mbytes on a Virtex II-Pro could
      take 0.92 ms [2] if the Internal Configuration Access Port
      (ICAP) is fed at the over-clock frequency of 300 Mhz. Thus,
      developing techniques to minimize the reconfiguration time
      overhead, making the use of PR more effective is crucial.
      Among several techniques, configuration prefetching is
      known as an effective technique for hiding the reconfiguration
      delay of hardware accelerators (tasks) in Partial Region FPGA.
      The principle of prefetching is to load a task as soon as
      c
      978-1-4799-5356-1/14/$31.00 2014 IEEE
      
    
    
      1
    
  
  
    
      take a significant time. J. Resano et al [1] presented a hybrid
      prefetch heuristic scheduling the reconfigurations at run time
      but carring out the scheduling computations at design-time. K.
      Jiang et al [7] proposed a CLP formulation and a heuristic that
      schedules prefetches and simultaneously performs HW/SW
      partitioning in order to reduce the expected execution time
      of an application. J. Edward [8] et. Al. presented an algorithm
      which predicts hardware execution and tries to prefetch hard-
      ware as early as possible while minimizing the risk of mis-
      prediction. The reconfigurable region is a 1D FPGA with n
      columns of the same size and they consider that the placements
      of the hardware modules are fixed in advance. Y. Qu et al [9]
      presented three static bases scheduler using prefetching, the
      first is developed from list-based schedulers where each task
      has a priority representing the urgency of the configuration.
      The second is based on constraint programming and the last
      uses a guide random search strategy. The target architecture is
      one-dimensional configuration model. J. Li [10] presented an
      interesting configuration prefetching approach to reduce the
      reconfiguration overhead for FPGA. However, the prediction
      for loading task may be erroneous and the task is loaded with
      the consequent penalization.
      The main difference of our work compared to all previous
      works is that in our work, the loading time for each task
      is decided at runtime, we consider that we do not have
      information about the entire future but only the very near
      future. Moreover, while previous works target the 1D and/or
      2D homogenous FPGA, we address the 2D heterogeneous
      FPGA which is the case of all most recent FPGAs. This
      heterogeneity imposes stricter placement constraints for task
      and requires a different strategy of placement compared to a
      homogenous FPGA.
    
    
      overhead, an example with different scheduling solutions for
      the task graph in Fig 1.a is studied. Fig 1.b shows the case
      when prefetching technique is not used. Fig 1.c considers the
      prefetching but not the task placement. The placement of
      T
      2
      prevents , performing cannot be loaded immediately after
      T
      T
      3
      3
      . After
      finishes its execution and is
      the reconfiguration of
      T
      T
      2
      1
      can still not start. Fig 1.d shows an
      removed from FPGA,
      T
      3
      example of prefetching with consideration of placement for
      T
      2
      and but an ineffective start of loading time. If
      is loaded
      T
      T
      3
      3
      , the overall execution time will be longer than
      in advance
      T
      2
      is loaded before. Therefore, the order
      in Fig 1.e case when
      T
      2
      of tasks to be loaded and the placement decision are extremely
      important parameters to reduce the reconfiguration overhead.
      Finding the best solution in terms of overall execution time
      is an NP-hard problem when task scheduling, placement and
      configuration prefetching all need to be considered at one time.
      Different decisions of scheduling and placement could produce
      different solutions of overall execution time. The effort to find
      the best solution by seeking all the possibilities can not be
      solvable in polynomial time. Thus, it is necessary to develop
      a run-time spatio-temporal scheduling heuristic which is able
      to give a good solution in a short time. To achieve it, in this
      paper, we propose a new heuristic for run-time scheduling
      and placement of tasks on a 2D heterogeneous eFPGA layer
      in order to minimize the overall latency of the application.
      Our heuristic tries to load tasks as early as possible while
      considering two factors: the priority of new tasks to be loaded
      and the placement decision to avoid conflicts between tasks.
      The remainder of the paper is organized as follows. The
      next section introduces the related work. Section 3 describes
      the architecture model, task model and the objective. Section
      4 details our scheduling and placement heuristic. Section 5
      presents the experimental results and Section 6 concludes the
      paper with some perspectives.
    
    
      III. MODEL AND OBJECTIVE
      In this section, we present the platform overview and explain
      how the accelerators (tasks) are managed on it. Then we
      present the platform model and the application model. From
      these models, the problem formalization is presented at the
      end of this section.
    
    
      TATE OF THE ART
      II. S
      In the literature, several techniques have been addressed
      to reduce the reconfiguration overhead, such as: configuration
      compression [3], configuration caching [4] and configuration
      prefetching. Elena perez-ramo et al [5] also proposed a survey
      of various techniques to reduce the reconfiguration overhead.
      However, in this paper, we concentrate only on the related
      works about configuration prefetching.
      F. Redaelli et al [6] proposed an exact ILP formulation for
      the task scheduling problem on 2D homogeneous reconfig-
      urable FPGAs in order to minimize the overall latency of the
      application. They proposed the Napoleon heuristic based on
      prefetching technique that reaches a good solution in a short
      time but the heuristic didn't allow finding a feasible schedule
      and mapping at runtime. All decisions are taken at design-time,
      the heuristic must know in advance the task graph in order to
      compute and sort the task set in increasing order of ALAP val-
      ues before starting the scheduling and placement step. It is not
      always the case for applications where the behavior of tasks
      can be changed at run time. Moreover, for complicated task
      graphs with many dependent tasks, Napoleon heuristic could
    
    
      A. Platform description
      Our target 2D heterogeneous FPGA is inspired from the
      eFPGA layer of a 3D stacked chip in the ongoing Flex-
      tiles project [11]. The 3D stacked chip is composed of a
      manycore layer and a reconfigurable (eFPGA) layer as in
      Fig 2. The manycore layer contains several General Purpose
      Processor (GPP) and Digital Signal Processor (DSP) cores.
      The reconfigurable layer, dedicated for hardware accelerators,
      is used to provide a high level of flexibility by support the
      feature of dynamic reconfigurable paradigm. The NoC on the
      manycore layer is used to support the communication between
      processors, between processors and accelerators, or between
      accelerators.
      In this paper, we focus on the scheduling and placement of
      dependent accelerators on a 2D heterogeneous reconfigurable
      architecture. Thus, we simplify the Flextiles architecture in
    
    
      2
    
  
  
    
      Fig. 2. Flextiles architecture Overview
    
    
      order to reduce the complexity of the problem. However, this
      reduction does not affect the mean fullness of our approach but
      allows to focus on the essential research and evaluation. This
      architecture is based on a large reconfigurable area connected
      to one processor via a bus which supports the communication
      between accelerators, see Fig 3. The processor supports the
      execution of an Operating System able to control the task
      management. Furthermore, this architecture contains a shared
      memory for the storage of data transferred between tasks when
      needed.
      The 2D heterogeneous FPGA has different types of re-
      sources, which are symmetrically located at fixed positions on
      the layer (see Fig 3): computing resources (configurable logic
      blocks - CLBs), memory resources (Blockram - BRAMs) for
      storing data during computations and Accelerator Interfaces
      (AIs) to provide access points between processors and accel-
      erators. Fitting with the reconfigurable technology based on
      a virtual bitstream, the symmetry of resources on the layer
      allows a high flexibility in terms of accelerator relocation and
      increases the designer degree of freedom.
    
    
      Configurable 
      Logic Block (CLB) 
    
    
      Accelerator 
      Interface (AI) 
    
    
      Fa 
      Δy
    
    
      BRAM bloc 
    
    
      Fb 
      Δy
      Δx
      Fb 
      Fa 
      x
      Δ
    
    
      Communication 
      bus 
    
    
      
    
    
      
      
    
    
      Fig. 3. 2D Heterogenous FPGA
    
    
      We consider that an accelerator must contain at least one
      AI and one BRAM. The BRAM is used in each accelerator
      to receive the data from other accelerators and also to store
      data during its execution. The AI is used to homogenize
      the control of accelerators by the processor, but also enables
      data transfer from/to software and to/from hardware execution.
      The functionality of the AI is supposed to be the same as
      in Flextiles and it offers various management services as
      configuration, control, and debug. Each AI is connected to the
      communication bus as described in Fig 3. When an accelerator
    
    
      requires more than one AI, one of them must become active
      and support the communications, others stay inactive. If two
      accelerators need a data exchange, the operating system must
      configure two I/O AIs of these two accelerators for setting
      up the communication. Then, data will be sent from one
      AI to another AI. The shared memory is needed when one
      accelerator must send data to another accelerator which has
      not been configured yet due to some dependencies.
      B. Platform model
      The execution platform for our problem is an FPGA which
      is defined by its size
      , with
      and
      the width
      F w, F h
      F w F h
      (
      )
      and the height of the FPGA in number of logic elements. Due
      to the symmetry of the FPGA, the locations of BRAMs (or
      AIs) are defined by the distance between two adjacent BRAMs
      (or AIs) but also by the position of the first instance of the
      block. The horizontal (respectively vertical) distance between
      (respectively
      ) and the position
      two BRAMs is
      F b
      F b
      x
      y
      Δ
      Δ
      and
      . The
      of the first BRAM instance is given by
      F b
      F b
      x
      0
      y0
      same distances and initial position of first instance are defined
      for the AI, as
      ,
      ,
      and
      . The coordinates
      F a
      F a F a
      F a
      x
      y
      x
      y
      Δ Δ
      0
      0
      corresponds to the bottom left corner of the FPGA.
      ,
      (0 0)
      From these values, the size of FPGA and the location of the
      different elements can be defined and all symmetrical FPGAs
      can be supported. An FPGA is then completely defined by
      , F b , F b , F b ,
      F P GA
      F w, F h , F b
      ) (
      )
      = (
      ) (
      x
      y
      x
      y
      0
      0
      Δ Δ
      {
      (1)
      F a
      , F a , F a , F a
      (
      ) (
      )
      x
      y
      x
      y
      0
      0
      Δ Δ
      }
      As an example, the FPGA represented in Fig 3 can be defined
      as
      F P GA
      ,
      , , , , , , , ,
      = (30 18) (6 3) (8 8) (2 0) (8 8)
      {
      }
      the total amount of BRAMs and
      We call
      Na
      Nb
      total
      total
      the total amount of AIs on the FPGA;
      (respectively
      Nb
      total
      ) is computed by an evaluation of the amount of
      Na
      total
      BRAMs (respectively AIs) which can be placed in the area
      defined by
      . This computation is given by
      F w F h
      ∗
      Nb
      F w F b
      /F b
      = ( (
      1)
      + 1)
      total
      x
      x
      0
      Δ
      (
      − −
      (
      (2)
      F h F b
      /F b
      ( (
      1)
      + 1)
      y
      y
      0
      Δ
      ∗ ( −
      −
      (
      Reconfiguration of hardware task on such platform consists in
      allocating a rectangular zone and loading the bitstream towards
      the reconfiguration port. A task is supposed relocatable in
      several regions of the FPGA, the possible regions are defined
      by the presence of the necessary resources. In this context,
      as FPGA definition, the model of an hardware task is defined
      by its size, and the location of each specific block included
      inside. So this model is defined as
      (3)
      Mw , Mh , Mb , Mb
      , Ma , Ma
      M
      = (
      ) (
      ) (
      )
      i
      i
      i
      i,x
      i,y
      i,x
      i,y
      0
      0
      0
      0
      {
      }
      and
      are the width and height of the model
      with
      Mh
      M
      Mw
      i
      i
      i
      for a relocatable and reconfigurable task ,
      T Mb , Mb
      (
      )
      i
      i,x
      i,y
      0
      0
      ,
      the position of the first instance of BRAM in the model
      M
      i
      the first instance of AI in the model
      .
      and
      , Ma
      M
      Ma
      )
      (
      i,x
      i,y
      i
      0
      0
      We define
      as the amount of BRAMs required by task ,
      Nb
      T
      i
      i
      T
      i
      for the task ,
      Na
      T Nb
      total
      i
      i
      the amount of AIs required by task . By applying the
      Na
      i
      and
      Nb
      total
      and
      could be computed.
      Na
      same calculation as
      i
    
    
      3
    
  
  
    
      C. DAG graph
      Similar to some of previous works, we use Directed Acyclic
      Graph (DAG) to represent dependent tasks. Applications, e.g.
      image processing, containing a linear sequence of tasks which
      exchange large amounts of data between them, are examples of
      this type of graph. DAG is denoted
      where is a
      G T, E
      T
      = ( )
      set of
      nodes and is a set of
      directed edges. Each node
      N
      E
      N
      T
      e
      , while an edge
      in DAG represents a task
      i
      , . . . , N
      T
      = 1
      i
      T
      ∀
      signifies that data produced by one task is used by another one.
      A task is not ready for scheduling until all its predecessors are
      finished, we note
      the list of predecessors of tasks
      P red T
      (
      )
      i
      .
      which produce data for the task
      T
      i
      As a task is a hardware task, it is necessary to specify not
      ) for each task but also i) the
      only the execution time (
      T run
      i
      ), and ii) the model for
      ( ).
      reconfiguration time (
      T M
      T rec
      i
      i
      i
      The communication time between tasks is not considered
      since it is taken into account by the execution time. Fig 1.a
      shows an example of DAG, each task
      is represented by
      T
      i
      . The parameter
      of each task represents
      , T run , M
      M
      T rec
      )
      (
      i
      i
      i
      i
      and is illustrated by
      the corresponding model of the task
      T
      i
      as in Fig 1.a. According to the
      the small rectangle next to
      T
      i
      = {(9,7), (6,0),
      model definition of task, we can describe
      M
      1
      (2,5)},
      = {(12,8), (6,1), (2,6)}, etc.
      M
      2
      D. Formalization of the Spatio-temporal scheduling problem
      The objective of our algorithm is to minimize the overall
      execution time of dependent tasks running on 2D heteroge-
      neous FPGA. To achieve that, the scheduler must be able to
      handle all the following requests:
      when to reconfigure a task (temporal reconfiguration) ?
      •
      where to place the task (spatial reconfiguration) ?
      •
      when to start the execution of a task according with its
      •
      precedence constraints (temporal scheduling) ?
      An ILP formalization for scheduling and placement of tasks
      on 2D homogenous FPGA is described in [6]. As we consider
      the heterogeneity of the FPGA, different types of resources
      and also the placement constraints of tasks on these resources
      must be taken into account. In this part, we introduce a
      formalization with the objective function to optimize and the
      main constraints of task scheduling and placement. We first
      •
      •
      •
      •
      •
      •
      •
      •
      define some variables as
      : time that
      starts to be loaded in FPGA
      T l
      T
      i
      i
      : time that
      starts to be executed in FPGA
      T e
      T
      i
      i
      if
      is present on FPGA at time , otherwise;
      T a
      T
      t
      = 1
      0
      i,t
      i
      if
      can be placed on the reconfigurable
      P
      T
      = 1
      T ,R
      i
      i
      k
      ,
      otherwise.
      is defined below.
      zone
      R
      R
      0
      k
      k
      if the reconfiguration port is free at time ,
      F R
      t
      = 1
      0
      t
      otherwise. We suppose that only one reconfiguration port
      is possible, i.e. only one task can be loaded at a time.
      t
      T
      : amount of non-utilized BRAMs on FPGA at time
      Nb
      f,t
      t
      : amount of non-utilized AIs on FPGA at time
      Na
      f,t
      : the overall execution time of the task graph
      t
      global
      t
      max T e T run
      i
      , . . . , N
      = 1
      with
      global
      i
      i
      {
      }
      ∀
      the total amount of tasks in the graph
      = ( + ) ;
      N
    
    
      T
    
    
      1) Objective: Minimizing the overall execution time of the
      task graph defined as
      (5)
      min t
      )
      (
      global
      This minimization must respect followings constraints:
      2) Placement Constraints: First of all, the minimization
      must ensure that all the tasks are scheduled one and only one
      time during the execution of the application. This constraint
      is defined as
      (6)
      P
      i
      , . . . N
      R
      = 1
      = 1
      k T ,R
      T
      i
      k
      |
      ∀
      ∃
      a feasible region for the task , defined as
      with
      T
      R
      k
      i
      (7)
      R
      Rx , Ry , Rx Mw , Ry Mh
      =
      +
      +
      k
      k
      k
      k
      i
      i
      i
      {
      }
      and
      the coordinates of the reconfigurable zone
      with
      Ry
      Rx
      k
      k
      . We call
      a feasible region for
      when and only when
      R
      T
      R
      k
      k
      i
      •
      •
      •
      (4)
      it satisfies three following conditions:
      The amount of BRAMs (respectively AIs) required by
      must be less than the amount of non-utilized BRAMs
      T
      i
      (respectively AIs) on the FPGA at time , for
      t
      t T l
      =
      i
      (8)
      Nb < Nb
      Na < Na
      &
      i
      f,t
      i
      f,t
      and
      are calculated by :
      Na
      Nb
      f,t
      f,t
      Nb
      Nb
      Nb T a
      =
      = 1
      f,t
      total
      j
      j,T l
      i
      
      −
      |
      j
      (9)
      Na
      Na T a
      Na
      =
      = 1
      f,t
      total
      j
      j,T l
      i
      
      −
      |
      j
      If
      is placed at coordinate
      , all resources
      T
      Rx , Ry
      (
      )
      i
      k
      k
      must fit on available resources of FPGA. This
      of
      T
      i
      condition can be expressed by the following constraints
      Rx
      Mb
      F b
      m F b
      m N
      +
      =
      +
      k
      i,x
      x
      x
      0
      0
      1
      Δ
      1
      ∗
      | ∃
      ∈
      (10)
      Ry
      Mb
      F b
      m F b
      m N
      +
      =
      +
      k
      i,y
      y
      y
      0
      0
      2
      Δ
      2
      ∗
      | ∃
      ∈
      Rx
      Ma
      F a
      m F a
      m N
      +
      =
      +
      k
      i,x
      x
      x
      0
      0
      3
      Δ
      3
      ∗
      | ∃
      ∈
      (11)
      Ry
      Ma
      F a m F a
      m N
      +
      =
      +
      k
      i,y
      y
      y
      0
      0
      4
      Δ
      4
      ∗
      | ∃
      ∈
      The first line of these constraints means that if the task
      T
      i
      is placed on the reconfigurable zone , a first BRAM
      R
      k
      , or
      must be found at horizontal relative position
      Mb
      i,x
      0
      absolute position
      . This verification is true if
      Rx
      Mb
      +
      k
      i,x
      0
      a BRAM exists at this absolute position on the FPGA. We
      use the symmetric formalization of the FPGA platform
      to verify if a BRAM is located at a horizontal position
      . If
      exists, it means that a
      m F b
      m N
      F b
      +
      x
      x
      0
      1
      Δ
      1
      ∗
      ∈
      BRAM is present at this location. The same verifications
      are done for other BRAMs, and also AIs.
      The rectangle
      R Rx , Ry , Rx Mw , Ry
      = (
      +
      +
      k
      k
      k
      k
      i
      k
      does not overlap with other tasks currently placed
      Mh
      )
      i
      R
      P
      = 1
      l
      T ,R
      j
      l
      (
      ∃
      |
      on the FPGA and does not be larger than FPGA size.
      )
      (12)
      T a
      j i
      = 1 =
      j,T l
      i
      ∧
      ∀ (
      Rx < Rx Mw
      (
      + )
      k
      l
      j
      ∧
      Rx
      Mw > Rx
      (
      + )
      k
      i
      l
      ∧
      k
      ∧
      Ry
      (
      k
      ∧
      (0
      ∧ ≤
      (0
      ∧ ≤
      Ry < Ry Mh
      (
      + )
      l
      j
      Mh > Ry
      + )
      i
      l
      k
      Ry
      k
      Rx < Rx Mw F w
      +
      k
      i
      ≤
      +
      )
      k
      i
      < Ry Mh F h
      ≤
    
    
      4
    
  
  
    
      : list of the tick time for the operating system
      timeList
      t
      •
      : list of tasks present on FPGA at time
      currentT asks
      t
      •
      : list of tasks available to be scheduled at time
      T L
      t
      •
      : list of next available successors of
      whose prede-
      L
      T
      i
      •
      ) have all been scheduled and allocated
      cessors (except
      T
      i
      : list containing tasks available to be scheduled at time
      P L
      •
      .
      is the fusion
      t and next available successors of
      P L
      T
      i
      list of
      (without
      ) and
      T L
      T
      L
      i
      ,
      ,
      ,
      ,
      ,
      : parameters de-
      F P GA F R T rec T run T e R
      i
      i
      i
      k
      •
      fined in the previous section
      These parameters will be updated at each time .
      t
    
    
      TL}
    
    
      Scheduling and Placement heuristic
      function ScheduleAndPlacement {
      = 0
      t
      =
      timeList
      ∅
      .add(StarterTask)
      T L
      while
      do
      T L
      =
      (
      ∅
      Update(
      ,
      ,
      )
      F P GA currentT asks F R
      for all
      do
      T i T L
      ∈
      Establish : {Tj = nextAvailableSuccessors(Ti) Tj
      L
      /
      |
      )
      ∈
      =
      P L T L T i L
      \ ∪
      findFewestConflictRegion( ,
      )
      R
      T i P L
      k
      ←
      if
      and (
      == 0) then
      R F R
      k
      ∃
      = 1
      F R
      .load( )
      F P GA T
      i
      .add( )
      currentT asks T
      i
      .add( +
      ,
      ,
      +
      timeList
      i
      t T rec T e T e T run
      i
      i
      i
      .delete( )
      T L T i
      .add( )
      T L L
      Sort
      in descending order of execution time
      T L
      break;
      end if
      end for
      )
      .delete( )
      timeList
      t
      = min(
      t
      timeList
      end while
      }
      Algorithm 1
      1:
      2:
      3:
      4:
      5:
      6:
      7:
      8:
      9:
      10:
      11:
      12:
      13:
      14:
      15:
      16:
      17:
      18:
      19:
      20:
      21:
      22:
      23:
      24:
      25:
    
    
      The first five lines of the constraint defined in equation
      12 verifie that it does not exist another rectangle
      R
      =
      l
      currently on the
      Rx
      , Ry , Rx Mw , Ry Mh
      (
      +
      + )
      l
      l
      l
      j
      l
      j
      . The
      FPGA for which there is an intersection with
      R
      k
      must be located
      last two lines of the constraint mean
      R
      k
      inside the FPGA area.
      can be loaded at
      3) Reconfiguration Constraints: A task
      T
      i
      on the FPGA when and only when it satisfies
      time
      t
      T l
      =
      i
      the following conditions:
      At least one feasible position for
      is found, i.e.
      R T
      k
      i
      •
      (13)
      R
      P
      = 1
      k T ,R
      i
      k
      ∃
      |
      The configuration port at time
      is free; i.e
      T l
      i
      •
      (14)
      F R
      T l
      i
      = 0
      All predecessors of
      finished their reconfigurations, i.e
      T
      i
      •
      (15)
      max T l
      T rec j T P red T
      T l
      (
      + )
      ( )
      i
      j
      j
      j
      i
      ≥
      ∀ | ∈
      can be executed at
      4) Execution Constraints: A task
      T
      i
      on the FPGA when and only when it satisfies
      time
      t
      T e
      =
      i
      the following conditions:
      the reconfiguration of
      is finished, i.e.
      T
      i
      •
      (16)
      T e
      T l
      T rec
      +
      i
      i
      i
      ≥
      all predecessors of
      finished their executions, i.e.
      T
      i
      •
      (17)
      T e
      max T e T run j T P red T
      (
      + )
      ( )
      i
      j
      j
      j
      i
      ≥
      ∀ | ∈
      CHEDULING AND LACEMENT HEURISTIC
      P
      IV. S
      Even if the optimal solution could be found by using Branch
      and Bound technique that searches for all ILP solutions first,
      and then takes out the best solution, the effort in time required
      for the calculation is large. Our heuristic targets runtime
      applications and does not try to find the best solution but aims
      at finding a "good" solution in terms of the overall execution
      time (equation 5) in a short time. As mentioned earlier, in our
      case, the scheduler does not have information about the entire
      task graph. Indeed, each task has uniquely the information
      of its predecessors and its successors. We suppose that these
      informations are only known by the operating system when
      the task is scheduled.
      The algorithm is based on an heuristic which consists
      in prefetching tasks as early as possible while considering
      two factors: the priority of new tasks to be loaded and the
      placement decision to avoid conflicts between tasks. The
      detail of our heuristic is given in two parts: Scheduling and
      Placement. An example is given at the end of this section to
      ease the understanding of our heuristic.
      A. Scheduling
      shows the pseudocode of our heuristic. It is
      Algorithm
      1
      related to the spatio-temporal scheduling by determining when
      and where to reconfigure a task and when a task can be
      •
      executed. We list here the parameters used in the pseudocode:
      : current tick time of the operating system. is related to
      t
      t
      the time when a task starts (or finishes) its reconfiguration
      or its execution
    
    
      The
      works as follows. At the beginning,
      Algorithm
      t
      1
      equals to 0,
      is empty and
      contains only the
      timeList
      T L
      StarterTask (source) of the DAG task graph (line [2-4]). The
      main part of the algorithm is presented from line [5-24]
      detailing what happens at each time step . It is repeated until
      t
      is empty, i.e. all the tasks have been scheduled.
      T L
      The function
      checks whether a task finishing the
      Update
      reconfiguration or the execution at current time and then
      t
      updates the
      state, the
      list and the
      F P GA
      currentT asks
      reconfigurator port
      state.
      is busy during the reconfig-
      F R F R
      uration phrase of a task and becomes free when a task finished
      its reconfiguration. When a task finished its execution, it will
      be removed from the
      and also from the
      F P GA
      currentT asks
      list.
      After the updating phase, the scheduler will schedule
      and allocate tasks of
      one by one. The order of tasks
      T L
      to be scheduled follows their order in
      . At time
      T L
      t
      when
      is scheduled, the heuristic tries to find the fea-
      T
      i
      for placing
      onto FPGA in order to
      sible region
      T
      R
      k
      i
      favor the placement of other remaining available tasks in
      . This region
      and also next available successors of
      T L
      T
      i
      found by
      R
      f indF ewestConf lictRegion T i, P L
      (
      )func-
      k
      tion, must satisfy the conditions for the placement con-
      will be specified in
      f indF ewestConf lictRegion T i, P L
      (
      straints mentioned in the formalization part. The details about
      )
    
    
      5
    
  
  
    
      a 
    
    
      Begin
       = {} 
      FP
      = 0 
      nb 
    
    
      
    
    
      
      
    
    
      
      
      
      
    
    
      F 
    
    
      i
      ft
      ft
       <= Na ) 
       (Nb <= Nb ) 
      i
       & (Na
    
    
      b 
    
    
      T 
      
      
      
    
    
      
      
    
    
       F 
    
    
      BRAM 
      Non-utilized 
    
    
      the next section. If
      for
      exists (condition 13) and the
      R T
      k
      i
      will be loaded
      reconfigurator
      is free (condition 14),
      F R
      T
      i
      into the FPGA. Consequently,
      and
      timeList
      currentT asks
      will be updated, available successors of
      will also be added
      T
      i
      to . Then, to reduce the reconfiguration overhead, tasks in
      T L
      will be sorted in descending order of their execution time.
      T L
      Finally, we jump to the next tick time by performing the
      minimal value in
      is empty.
      (line [22-23]) and continue to
      schedule next task in
      timeList
      until
      T L T L
    
    
       T 
      
      
    
    
      c 
    
    
      F 
    
    
       BRAMs Fit 
    
    
      
    
    
      
    
    
      T 
    
    
      F 
    
    
      AIs Fit 
    
    
      d 
    
    
      T 
    
    
      F 
    
    
      NNon-overlap 
       Rectangles 
    
    
      
    
    
      
    
    
      T 
      
      
      ∪
    
    
      e 
    
    
      F 
    
    
      total
    
    
      ≤
      nb Nb
    
    
       End 
      Return 
      FP 
    
    
      T 
    
    
      B. Placement
      This section details the technique used in the function
      called by algorithm 1.
      , P L
      f indF ewestConf lictRegion T
      )
      (
      i
      The technique aims to find the most suitable position for
      T
      i
      at time when it is scheduled, can be divided into two parts:
      t
      the first part called Fast Feasible Region Search serves to find
      at time on the
      quickly all feasible regions for the task
      t
      T
      i
      FPGA, the second part called Avoiding Conflict Technique
      , then choose
      allows to evaluate all the feasible regions for
      T
      i
      the most suitable one to place
      .
      T
      i
      1) Fast Feasible Region Search: To the best of our knowl-
      edge, most of the hardware task placement algorithms deal
      with 1D or 2D FPGA homogenous architecture, for example
      KAMER [12], Vertex List [13], etc. However, real FPGAs have
      BRAM blocks, multipliers and DSPs in a certain disposition
      and this heterogeneity imposes stricter placement constraints
      for the task. Few algorithms deal with task placement on
      2D heterogeneous architecture. M.Koester [14] proposed a
      placement algorithm which is able to deal with the constraints
      of the hardware tasks. However, feasible positions of the task
      are not found in run-time. For each hardware task, the given
      set of feasible positions is predefined at design time. Eiche
      et al. [15] implemented an on-line placer for heterogeneous
      devices by using a discrete hopfield neuronal network. They
      consider that the FPGA is divided in several Partial Regions
      and a task must contain at least one of them. This consideration
      can create a waste of resources when a task does not need the
      entire resources in the PRR.
      In this part, we propose an efficient method allowing to find
      on the 2D heterogeneous
      quickly all reconfigurable regions
      R
      k
      can be matched at time . We define
      as the
      FPGA where
      t
      F P
      T
      i
      }). Instead of seeking
      set of these feasible regions (
      = {
      F P R
      k
      each logic block along
      and
      of the FPGA to find a
      F w F h
      feasible region
      , which is very time consuming, we propose
      R
      k
      to seek directly by the resources having fewest amounts on
      FPGA. In our case, the amount of BRAMs is less compared
      to AIs and CLBs, therefore we start scanning with BRAMs.
      The idea is trying to place the task in the region where the
      first BRAM of
      matched with a BRAM of the FPGA and
      T
      i
      checking whether the region created is a feasible region for the
      . Thus, by placing the first BRAM of
      successively
      task
      T
      T
      i
      i
      on all BRAMs of the FPGA, all feasible regions could be
      found. By doing this way, the complexity for searching feasible
      regions is reduced ( * )/
      times.
      F w F h Nb
      total
      Fig 4.a represents the proposed searching method. Before
      scanning BRAMs, we realize a first check about the amount of
    
    
      Fig. 4. Quick search method for finding all feasible regions
      for the task
      R
      k
      at time
      t
      T
      i
      non-utilized BRAMs (
      ) and AIs (
      ) on the FPGA at
      Nb
      Na
      f,t
      f,t
      time (condition 8). If the amount of BRAMs and AIs required
      t
      by the task is superior to the amount of non-utilized BRAMs
      and AIs on the FPGA, no feasible region is available for
      .
      T
      i
      On the contrary, we could start BRAMs scanning process. The
      BRAMs scanning step consists in scanning each BRAM of
      the FPGA one by one from the left to the right and then from
      the top to the bottom as in the figure 4.c. For each scanning
      iteration , if the BRAM is utilized (which is verified by
      nb
      BRAM non-utilized condition), we go to the next iteration. If
      not, we calculate the region
      where the first BRAM of
      R
      T
      k
      i
      can be matched with the BRAM of the FPGA. is a valid
      R
      k
      feasible region for the task
      when the conditions 10, 11 and
      T
      i
      12 are satisfied. BRAMs Fit Condition is used to check if all
      other BRAMs of the tasks are matched on the non-utilized
      BRAMs. If it is the case, the same process is done for AIs Fit
      condition. When BRAMs Fit condition and AIs Fit condition
      are satisfied, Non-overlap Rectangles (condition 12) must be
      respected to ensure that the created region
      will not overlap
      R
      k
      with other regions where other tasks are running and/or with
      is a valid feasible region, it
      the border of the FPGA. Once
      R
      k
      is added to
      and we scan the next BRAM until all BRAMs
      F P
      of the FPGA are scanned.
      Fig 4.b presents an example with
      is currently on the
      T
      1
      . Fig
      FPGA and we must find all feasible regions for
      T
      2
      with BRAM Non-utilized
      4.c shows an invalid region for
      T
      2
      condition not satisfied, Fig 4.d shows an invalid region with
      BRAMs Fit and AIs Fit condition satisfied but Non-overlap
      At
      time
      ,
      t
      are found,
      T
      i
      chooses the most
      rectangles condition not satisfied. Fig 4.e shows a valid feasi-
      .
      ble region for
      T
      2
      2) Avoiding conflicts
      technique:
      once all
      , P L
      f indF ewestConf lictRegion T
      )
      (
      feasible regions for
      i
    
    
      6
    
  
  
    
      
    
    
      
    
    
      
      
    
    
      
      
    
    
      t = 3 
    
    
      t = 1 
    
    
      t = 0 
    
    
      
    
    
      
    
    
      
    
    
      
      
    
    
      
    
    
      t = 9 
    
    
      t = 6 
    
    
      t = 4 
    
    
      suitable one that creates fewest conflicts with tasks in ,
      P L
      therefore favors the placement of next available tasks, to
      place
      . As mentioned,
      contains the next available tasks
      T
      P L
      i
      . We define parameters and
      and the next successors of
      p
      q
      T
      i
      with tasks in .
      which allow to evaluate the conflicts of
      P L
      T
      i
      , noted
      is found
      Firstly, the set of feasible regions for
      F P
      T
      i
      by using Fast Feasible Region Search presented in the previous
      part. Then, for each
      , we calculate the amount of
      R
      F P
      k
      ∈
      is supposed to be
      feasible regions for each task in
      if
      P L T
      i
      .
      is defined as the multiplication of all these
      placed at
      p
      R
      k
      amounts, and as the sum of all these amounts. Thus, for all
      q
      , the maximum value of , called
      feasible regions of
      p
      pmax
      T
      i
      and the maximum value of , call
      could be determined.
      q
      qmax
      equals 0 means one of the task in
      can not be placed due
      p
      P L
      to the feasible position if
      is placed on. This task must wait
      T
      i
      or other tasks to have the chance to
      until the extraction of
      T
      i
      be placed, thus delaying the execution of the following tasks.
      The more larger is, the more the tasks in have the chance
      p
      P L
      to be placed simultaneously on the FPGA, thus the more the
      reconfiguration overhead is reduced.
    
    
      R4 
    
    
      R5 
    
    
      R1 
    
    
      R.6 
    
    
      R2 
    
    
      R3 
    
    
      p 
    
    
       4*1 
    
    
       3*1 
    
    
       4*1 
    
    
       3*1 
    
    
       4*2 
    
    
      4*2 
    
    
      q 
    
    
       4+1 
    
    
       3+1 
    
    
       4+1 
    
    
       3+1 
    
    
       4+2 
    
    
      4+2 
    
    
      Fig. 6. Scheduling and placement of tasks on 2D heterogenous FPGA
      starts its execution. At that time, the reconfigurator becomes
      can start the reconfiguration. The placement of
      free and
      T
      T
      2
      2
      must favor the placement of next available task which is ,
      T
      3
      is placed as in the figure. At time 3, finished
      therefore
      T
      T
      2
      2
      its reconfiguration but it cannot start the execution phase due
      . The reconfigurator is free at
      to the unfinished execution of
      T
      1
      can start its reconfiguration. The placement of
      time 3, thus
      T
      3
      must favor the next available task . However, no available
      T
      T
      3
      4
      feasible region for
      is found wherever
      is placed on the
      T
      T
      4
      3
      finished its execution and is removed
      FPGA. At time 4,
      T
      1
      starts its execution. At time 6, finished
      from the FPGA,
      T
      T
      2
      3
      its reconfiguration and starts its execution. Finally, at time 9,
      and are finished their executions and are removed from
      T
      T
      2
      3
      the FPGA.
      can now be loaded. is placed far from the
      T
      T
      4
      4
      center as in the figure to favor the placement of next available
      is the last task to be scheduled,
      tasks. In the example,
      T
      4
      . After the time 9,
      thus there are no available tasks after
      T
      T
      4
      4
      will continue the reconfiguration and execution. At time 13,
      finished its execution and is removed from the FPGA. We
      T
      4
      mark 13 as the overall execution time for the task graph.
      ESULTS
      V. R
      In order to evaluate the quality of our proposed heuristic,
      we generate different examples of DAG graphs and compare
      the results produced by our heuristic to other techniques. The
      amount of tasks
      ranges from 5 to 14 tasks for each graph.
      N
      T
      In each graph, except the source task, one task has at least one
      predecessor. The reconfiguration time and the execution time
      range from 1 to 10 time units for each task, the width and the
      height of each task vary in the interval [6, 18]. A task must
      contain at least one AI and one BRAM.
    
    
      41
      39.06
      39
      48.06
      39
      39
      60.43
      54
      54
      56.5
      41.63
      41
      62.88
      48
      48
      68.41
      52.18
      51
      79.84
      68
      68
      69.88
      56
      56
      74.98
      58.48
      58
      102.7
      87
      87
      FFWOP RFWP Napoleon_ex Proposed
      33
      33
      53
      40
      44
      51
      66
      57
      58
      84
    
    
      N
      T
      5
      6
      7
      8
      9
      10
      11
      12
      13
      14
    
    
      TABLE I
    
    
      OMPARISONS OF THE OVERALL EXECUTION TIME FOR DIFFERENT TECHNIQUES
    
    
      C
    
    
      To offer more flexibility for task placement, we simulate the
      bigger FPGA described as FPGA = {(36,34), (6,3), (8,8), (2,0),
      (8,8)}. We compare our proposed heuristic with three different
      techniques: i) First Fit Without Prefetching (FFWOP), ii)
    
    
      Fig. 5. Calculation of parameters and to decide the placement of
      in
      p q
      T
      1
      and
      order to avoid conflicts with
      T
      2
      3
      T
      Our placement decision of
      is based on the region giving
      T i
      the value of
      in the case
      is different to 0. If there
      pmax
      pmax
      giving this value of
      ,
      is only one feasible region for
      pmax
      T
      i
      will be placed at this feasible region. In the case many
      T i
      feasible regions are possible, we will take the first furthest
      feasible region from the center. If
      is equal to 0, we will
      pmax
      take the region giving
      to finally place
      . The more
      qmax
      T
      i
      larger is, the more choices to place tasks in
      we have.
      q
      P L
      give the same
      ,
      In the case many feasible regions for
      qmax
      T
      i
      we will take the first furthest feasible region from the center.
      Fig 5 shows an example how to choose the suitable region
      of the task graph in Fig 1.a. By using the quick
      to place
      T
      1
      denoted , ,
      search method, six feasible regions for
      R R
      T
      1
      1 2
      etc. are found. According to the task graph and the scheduling
      algorithm, contains next available successors of
      which
      P L
      T
      1
      and . For each feasible region of
      ,
      and are
      are
      T
      T p
      q
      T
      2
      3
      1
      , 4 feasible regions for
      and
      calculated. For example, for
      T
      R
      1
      2
      are found, etc. Finally, seeing that
      2 feasible regions for
      T
      3
      will be chosen to place .
      is equal to ,
      T
      pmax
      R
      8
      1
      1
      C. Example
      Fig 6 shows by time steps the scheduling and placement of
      tasks defined in DAG of Fig 1.a. Three different colors are used
      to differentiate the reconfiguration phase, the execution phase
      of
      are and , thus
      is placed as in Fig 6 at time 0
      T
      T
      T
      1
      2
      3
      and . spends 1 time unit
      to favor the placement of
      T T
      3 1
      finished its reconfiguration and
      to reconfigure. At time 1,
      or pending the execution of a task. Next available successors
      T
      1
      T
      T
      2
      1
    
    
      7
    
  
  
    
      heterogeneous FPGA. We present as well a technique allow-
      ing to search quickly feasible positions of the task on the
      FPGA. The results show that our proposed heuristic reduces
      significantly the overall execution time compared to some non-
      prefetching and other prefetching methods. This work will be
      extended by taking into account : i) the reused module for a
      hardware task and ii) the software executions, thus a task can
      exist in hardware and/or software. An efficient scheduler must
      be proposed in order to give a good solution in term of the
      overall time of the application.
      REFERENCES
      [1] J. Resano, D. Mozos, and F. Catthoor, "A hybrid prefetch scheduling
      heuristic to minimize at run-time the reconfiguration overhead of dy-
      namically reconfigurable hardware," in Proceedings of the conference
      on Design, Automation and Test in Europe-Volume 1. IEEE Computer
      Society, 2005, pp. 106-111.
      [2] C. Claus, F. Altenried, and W. Stechele, "Dynamic partial reconfigu-
      ration of xilinx fpgas lets system adapt on the fly," Xcell journal, pp.
      18-23, 2010.
      [3] Z. Li and S. Hauck, "Configuration compression for virtex fpgas," in
      Field-Programmable Custom Computing Machines, 2001. FCCM'01.
      The 9th Annual IEEE Symposium on. IEEE, 2001, pp. 147-159.
      [4] Z. Li, K. Compton, and S. Hauck, "Configuration caching management
      techniques for reconfigurable computing," in Field-Programmable Cus-
      tom Computing Machines, 2000 IEEE Symposium on. IEEE, 2000, pp.
      22-36.
      [5] E. P. Ramo, J. Resano, D. Mozos, and F. Catthoor, "Reducing the
      reconfiguration overhead: a survey of techniques." in ERSA, 2007, pp.
      191-194.
      [6] F. Redaelli, M. D. Santambrogio, and S. O. Memik, "An ilp formula-
      tion for the task graph scheduling problem tailored to bi-dimensional
      reconfigurable architectures," International Journal of Reconfigurable
      Computing, vol. 2009, p. 7, 2009.
      [7] K. Jiang, P. Eles, and Z. Peng, "Co-design techniques for distributed
      real-time embedded systems with communication security constraints,"
      in Design, Automation &amp; Test in Europe Conference &amp; Exhi-
      bition (DATE), 2012. IEEE, 2012, pp. 947-952.
      [8] J. E. Sim, W.-F. Wong, G. Walla, T. Ziermann, and J. Teich, "Interpro-
      cedural placement-aware configuration prefetching for fpga-based sys-
      tems," in Field-Programmable Custom Computing Machines (FCCM),
      2010 18th IEEE Annual International Symposium on. IEEE, 2010, pp.
      179-182.
      [9] Y. Qu, J.-P. Soininen, and J. Nurmi, "A parallel configuration model
      for reducing the run-time reconfiguration overhead," in Proceedings of
      the conference on Design, automation and test in Europe: Proceedings.
      European Design and Automation Association, 2006, pp. 965-969.
      [10] Z. Li, "Configuration management techniques for reconfigurable com-
      puting," Ph.D. dissertation, Citeseer, 2002.
      [11] F. Lemonnier, P. Millet, G. M. Almeida, M. Hubner, J. Becker, S. Pille-
      ment, O. Sentieys, M. Koedam, S. Sinha, K. Goossens et al., "Towards
      future adaptive multiprocessor systems-on-chip: an innovative approach
      for flexible architectures," in Embedded Computer Systems (SAMOS),
      2012 International Conference on. IEEE, 2012, pp. 228-235.
      [12] K. Bazargan, R. Kastner, and M. Sarrafzadeh, "Fast template placement
      for reconfigurable computing systems," IEEE Design &amp; Test of
      Computers, vol. 17, no. 1, pp. 68-83, 2000.
      [13] J. Tabero, J. Septién, H. Mecha, and D. Mozos, "Allocation heuristics
      and defragmentation measures for reconfigurable systems management,"
      Integration, the VLSI Journal, vol. 41, no. 2, pp. 281-296, 2008.
      [14] M. Koester, M. Porrmann, and H. Kalte, "Task placement for heteroge-
      neous reconfigurable architectures," in Field-Programmable Technology,
      2005. Proceedings. 2005 IEEE International Conference on. IEEE,
      2005, pp. 43-50.
      [15] A. Eiche, D. Chillet, S. Pillement, and O. Sentieys, "Task placement
      for dynamic and partial reconfigurable architecture," in Design and Ar-
      chitectures for Signal and Image Processing (DASIP), 2010 Conference
      on. IEEE, 2010, pp. 228-234.
    
    
      Random Fit With Prefetching (RFWP) and iii) Napoleon
      (Napoleon_ex). The FFWOP algorithm does not consider the
      prefetching technique and the order of tasks to be loaded into
      the FPGA. In FFWP, tasks are placed at the first available
      region. RRWP considers the prefetching technique but not
      the order of tasks. In RRWP, tasks are placed randomly
      on the FPGA at one of its feasible positions. Napoleon's
      heuristic [6] is very close to our heuristic by considering the
      prefetching technique and also the task placement. Compared
      to the Napoleon, our heuristic has two different points: i)
      While Napoleon algorithm computes the order of tasks to be
      scheduled at design-time, our algorithm attributes the priority
      for the tasks at run-time. ii) The placement in Napoleon
      algorithm addresses the 2D homogenous FPGA and it uses
      furthest placement criteria in order to increase the probability
      of placing large modules quickly. In our heuristic, the place-
      ment takes care of 2D heterogeneous FPGA and the new task
      will be placed in the region creating fewest conflicts with other
      tasks. To compare our heuristic with Napoleon, we extend the
      basic Napoleon to take into account of the heterogeneity of
      the task and the FPGA.
      The table I shows the comparisons of the overall execution
      time produced by our proposed heuristic with FFWOP, RFWP
      and Napoleon extension. In this table, 10 examples of task
      graph are analyzed. Because FFWOP, RFWP and Napoleon
      do not consider the order of tasks to be loaded into the FPGA,
      thus at time when several tasks are ready to be scheduled, a
      t
      task is chosen randomly among these tasks to be scheduled.
      In our examples, for each task graph, FFWOP, RFWP and
      Napoleon are run 100 times each with the order of tasks is
      randomly chosen every time. The values produced by FFWOP,
      RFWP and Napoleon in the table I are the average overall time
      of these 100 times. By performing the random order of tasks,
      we can compare fairly our heuristic with others.
      For almost cases, our heuristic gives the shortest overall
      execution time. According to the table I, our heuristic con-
      sidering the order of tasks to be loaded and the avoid conflict
      placement technique reduces significantly by 22,5% the overall
      execution time compared to FFWOP and approximately 5%
      equals
      compared to RFWP and Napoleon. In the case with
      N
      T
      12, the overall execution time produced by our proposed
      heuristic are slightly greater than RFWP and Napoleon. This
      difference is due to the fact that the scheduler does not have
      the entire information of the task graph. The information about
      the successors of a task is only known when the task starts
      reconfiguring into the FPGA, therefore at the time the list of
      t
      next available tasks contains only tasks which will be ready
      to be scheduled in the near future from . Then, our heuristic
      t
      favors the placement of next available tasks but cannot predict
      the placement of far future tasks. However, in some case, the
      placement of the task
      at the time can impact on the
      T
      t
      i
      that was not in the next available task list
      placement of
      T
      j
      at time .
      t
      ONCLUSION
      VI. C
      In this work, we introduce a heuristic to minimize the
      overall execution time of dependent tasks executed on 2D
    
    
      8
    
  
